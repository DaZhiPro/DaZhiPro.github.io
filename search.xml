<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Django 概述</title>
      <link href="/2023/01/11/1-kai-fa/django/gai-shu/"/>
      <url>/2023/01/11/1-kai-fa/django/gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="新建第一个hello-world"><a href="#新建第一个hello-world" class="headerlink" title="新建第一个hello world"></a>新建第一个hello world</h2><ol><li><p>安装Django： <code>python -m pip install Django</code><br><a href="https://docs.djangoproject.com/zh-hans/4.1/topics/install/#installing-official-release">https://docs.djangoproject.com/zh-hans/4.1/topics/install/#installing-official-release</a></p></li><li><p>创建项目 <code>django-admin startproject mysite</code></p></li><li><p>创建hello world 应用 <code>python manage.py startapp helloworld</code></p></li><li><p>应用链接项目：在mysite的url中链接到helloworld应用的界面<br>—mysite&#x2F;urls.py—</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;helloworld/&#x27;</span>, include(<span class="string">&#x27;helloworld.urls&#x27;</span>)),</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>运行项目 <code>python manage.py runserver 127.0.0.1:7000</code></p></li></ol><h2 id="常见的初始化配置"><a href="#常见的初始化配置" class="headerlink" title="常见的初始化配置"></a>常见的初始化配置</h2><ul><li><p>数据库<br>安装mysql、新建数据库、配置账户密码<br>—-mysite&#x2F;setting.py—</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">  <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;poll&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;654321&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;PORT&#x27;</span>: <span class="string">&#x27;3306&#x27;</span>,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>时区</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TIME_ZONE = <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">USE_TZ = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>django 的 url 中的 path 函数提供路由功能，将用户的每个 url 映射到views中的某个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>url 中带参数：<br><code>path(&#39;&lt;int:question_id&gt;/vote/&#39;, views.vote, name=&#39;vote&#39;)</code></p><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><h3 id="后端和数据库的数据传输"><a href="#后端和数据库的数据传输" class="headerlink" title="后端和数据库的数据传输"></a>后端和数据库的数据传输</h3><ol><li>在model中定义模型 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Question</span>(models.Model):</span><br><span class="line"> question_text = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line"> pub_date = models.DateTimeField(<span class="string">&#x27;data published&#x27;</span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">     <span class="keyword">return</span> self.question_text</span><br></pre></td></tr></table></figure></li><li>运行 <code>python manage.py makemigrations</code> 为模型的改变生成迁移文件。</li><li>运行 <code>python manage.py migrate</code> 来应用数据库迁移。</li><li>运行 <code>python manage.py createsuperuser</code> 创建超级账户</li></ol><h3 id="前端和后端的数据传输"><a href="#前端和后端的数据传输" class="headerlink" title="前端和后端的数据传输"></a>前端和后端的数据传输</h3><ol><li>get 方式 url 中带参数<br>比如url中带question.id后端就把对应的问题从数据库中找出来</li><li>form 方式 字典的方式带数据<br>后端可以request.POST[‘choice’]来获取字典中choice对应的value</li></ol><h2 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h2><h3 id="操作数据API"><a href="#操作数据API" class="headerlink" title="操作数据API"></a>操作数据API</h3><p><em><strong>增</strong></em><br>q &#x3D; Question(question_text&#x3D;”What’s new?”, pub_date&#x3D;timezone.now())<br>q.save()</p><p><em><strong>删</strong></em><br>q &#x3D; Question.objects.get(pk&#x3D;1)<br>q.delete()<br><em><strong>查</strong></em><br><code>Question.object.all()</code> : 获取一个类的所有对象<br><code>q=Question.objects.get(pk=1)</code></p><p><em><strong>改</strong></em><br>q &#x3D; Question.objects.get(pk&#x3D;1)<br>q.question_text &#x3D; “xinzhi”<br>q.save()</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/10/hello-world/"/>
      <url>/2023/01/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>离散化</title>
      <link href="/2023/01/06/3-suan-fa/06-chi-san-hua/"/>
      <url>/2023/01/06/3-suan-fa/06-chi-san-hua/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/2023/01/06/3-suan-fa/05-shuang-zhi-zhen/"/>
      <url>/2023/01/06/3-suan-fa/05-shuang-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li>一般适用于什么情况？</li></ol><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>; i &lt; n; i ++)&#123; <span class="comment">// 看做快指针，尽管往前面跑</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; n &amp;&amp; <span class="built_in">check</span>(j,i)) j ++;  <span class="comment">// j 看做慢指针， 有需要的情况下跟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题的逻辑</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和 差分</title>
      <link href="/2023/01/05/3-suan-fa/04-qian-zhui-he-he-chai-fen/"/>
      <url>/2023/01/05/3-suan-fa/04-qian-zhui-he-he-chai-fen/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度</title>
      <link href="/2023/01/04/3-suan-fa/03-gao-jing-du/"/>
      <url>/2023/01/04/3-suan-fa/03-gao-jing-du/</url>
      
        <content type="html"><![CDATA[<h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>超长数字的加减乘除 ( len(A),len(B) &gt; 1e6 )</p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><ol><li><p>大数相加 C &#x3D; A + B</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123; <span class="comment">// 使用引用是为了加快速度，原数列A,B需要是逆序过得</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">// 表示向下一位的进位， 取 0 | 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || B.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(t); <span class="comment">// 向最高位进位</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>大数相减 C &#x3D; A - B</p></li></ol><p>&#96;&#96;&#96;c++<br>  void sub(vector<int> A, vector<int> B){</p><p>  }</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分</title>
      <link href="/2023/01/02/3-suan-fa/02-er-fen/"/>
      <url>/2023/01/02/3-suan-fa/02-er-fen/</url>
      
        <content type="html"><![CDATA[<h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a href="https://www.acwing.com/problem/content/791/">问题</a></h4><p>适用于一个序列，有一个check函数，能够使得序列左边都返回false，右边都返回true，然后我们找的就是这个分界点的时候</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>两种情况<br>一种是求 左半段最后一个元素，也就是说求上界，比如求 小于等于 x 的最后一个元素<br>这时候 <code>mid = l + r + 1 &gt;&gt; 1;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid , <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[mid] &lt;= x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid,x)) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>另一种情况是求 右半段的第一个元素，也就是求下界，比如求 大于等于 x 的第一个元素<br>这时候 <code>mid = l + r + 1 &gt;&gt; 1;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid , <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[mid] &gt;= x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid,x)) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>给定一个序列 q , 求大于等于 x 的第一个值 右半段的第一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid , <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[mid] &gt;= x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, mid;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">    mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid, x)) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(q[l] == x) ...</span><br></pre></td></tr></table></figure><p>给定一个序列 q , 求小于等于 x 的最后一个值 左半段的最后一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid , <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[mid] &lt;= x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, mid;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">    mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid, x)) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(q[l] == x) ...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2023/01/01/3-suan-fa/01-pai-xu/"/>
      <url>/2023/01/01/3-suan-fa/01-pai-xu/</url>
      
        <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a href="https://www.acwing.com/problem/content/787/">问题</a></h4><p>将序列 q 的 l ~ r 区间排序<br>void quick_sort(int q[], int l, int r) </p><h4 id="基本思想-——-分治"><a href="#基本思想-——-分治" class="headerlink" title="基本思想 —— 分治"></a>基本思想 —— 分治</h4><ol><li>找一个参考值 x</li><li>通过双指针算法交换使得  左半边全部是 &lt;&#x3D; x , 右半边全部是 &gt;&#x3D; x<ol><li>移动左指针 i ，找到大于 x 的数</li><li>移动右指针 j ，找到小于 x 的数</li><li>交换逆序对</li></ol></li><li>递归处理 左半边 右半边</li></ol><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l] + q[r] &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q[++ i] &lt; x);</span><br><span class="line">        <span class="keyword">while</span>(q[-- j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>( q, l, j), <span class="built_in">quick_sort</span>( q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点</strong>： 分界点的选择可以是[ l , j ]、 [ j + 1 , r ] 或者 [ l, i - 1 ]、[ i , r ],<br>swap 的时候不要忘记判断 i &lt; j</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>与快排的先排完上层，再排下层不同，归并排序是先排完下层再排上层</p><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a><a href="https://www.acwing.com/problem/content/789/">问题</a></h4><p>将序列 q 的 l ~ r 区间排序<br>void merge_sort(int q[], int l, int r) </p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ol><li>先排完左半边[ l , mid ]、再排完右半边[ mid + 1, r ]</li><li>将左右两个有序序列进行合并<ol><li>i , j 两个指针分别指向两个有序子序列的头，哪个小就输出哪个，并指向后一个，直到有一个序列指针到达末尾</li><li>将未全部输出的序列全部输出</li></ol></li><li>处理左半边 和 右半边 同样使用递归的方式</li></ol><h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp[N]; <span class="comment">// 很大，最好开在外面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>; <span class="comment">// 递归的出口</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid), <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j]) tmp[k ++] = q[i ++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++] = q[j ++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k ++] = q[i ++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k ++] = q[j ++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程登录和 vim</title>
      <link href="/2022/12/04/1-kai-fa/linux/yuan-cheng-deng-lu-he-vim/"/>
      <url>/2022/12/04/1-kai-fa/linux/yuan-cheng-deng-lu-he-vim/</url>
      
        <content type="html"><![CDATA[<h3 id="主机和虚拟机ping不通的原因"><a href="#主机和虚拟机ping不通的原因" class="headerlink" title="主机和虚拟机ping不通的原因"></a>主机和虚拟机ping不通的原因</h3><ol><li>主机需要将自己网卡共享给VMware net8</li><li>主机VMware net8虚拟网卡设计的网段需要和虚拟机中vmnet8 的网段设置为一样的<br>如果不一致，会出现主机ping不通虚拟机，反之可以，同时虚拟机也能上网</li></ol><h3 id="远程登录传输"><a href="#远程登录传输" class="headerlink" title="远程登录传输"></a>远程登录传输</h3><p>虚拟机ip  192.168.126.128   Vmwarenet8 196.168.126.0</p><p>连接工具： XShell 和 XFTP<br>连接的时候主机一定要选择虚拟机（就是linux所在主机）<strong>的ip</strong><br>小问题：如果使用XFTP出现乱码的话，将语言改为UTF-8</p><p>连接成功后就可以远程通过用户名和密码 远程登录到linux系统</p><h3 id="vim使用以及快捷键"><a href="#vim使用以及快捷键" class="headerlink" title="vim使用以及快捷键"></a>vim使用以及快捷键</h3><p>vim的三种模式</p><ol><li>正常模式 默认进去的模式，可以光标移动</li><li>编辑模式 正常+ i\a 可以进行编辑</li><li>命令模式 正常+：可以输入命令   :wq 保存并退出 :q! 强制退出</li></ol><h4 id="各种模式的切换"><a href="#各种模式的切换" class="headerlink" title="各种模式的切换"></a>各种模式的切换</h4><p><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221002232546072-1965942321.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221002232546072-1965942321.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h4 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h4><ul><li>yy 复制当前行  5yy 复制之后的5行    p 粘贴</li><li>dd 删除当前行  6dd删除当前行后的6行</li><li></li><li>:set nu 显示行号  :set nonu 取消行号</li><li></li><li>正常模式下：输入u撤销操作，就是输错了，先ESC，然后再u</li><li>正常模式下：跳转到第一行 gg  跳转到最后一行G</li><li>正常模式下： &#x2F;hello 回车 开始搜索文件中的hello  使用n选择next个匹配项</li><li>正常模式下：输入行号n，然后shift+g  go到第n行</li><li>任何模式切换为正常模式 按ESC键</li></ul><p><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221002234541152-1804272133.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221002234541152-1804272133.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 常用命令</title>
      <link href="/2022/12/01/1-kai-fa/linux/chang-yong-ming-ling/"/>
      <url>/2022/12/01/1-kai-fa/linux/chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><ol><li><p>删除 rm option 文件&#x2F;文件名<br>option  -r:删除目录及其子文件   -f: 即使原档案属性设为唯读，亦直接删除，无需逐一确认<br><code>sudo rm a.txt</code>  &#x2F;&#x2F;删除文件<br><code>sudo rm -r test</code> &#x2F;&#x2F;删除test文件夹</p></li><li><p>创建<br>创建文件 <code>touch a.txt</code>  创建a.txt 文件<br>创建文件夹  <code>mkdir a</code>   创建文件夹a</p></li><li><p>解压<br><code>tar -zxvf filename</code></p></li><li><p>用户操作<br>添加用户   <code>useradd 用户名</code><br>删除用户   <code>userdel -r 用户名</code></p></li><li><p>cd命令<br>cd a  是进入当前目录下的a文件夹中<br>cd &#x2F;a 是进入根目录下的a中  ‘&#x2F;‘代表根目录</p></li><li><p>开关机指令<br>shutdown -</p></li><li><p>关于相对路径的引用<br>a<br> -a1<br> -a2<br>b<br> -b1<br> -b2</p><ol><li>当前目录中的文件夹a1  \a1</li><li>上一级目录 ..\</li><li>同级目录b  ..\b</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 概述和安装</title>
      <link href="/2022/11/28/1-kai-fa/linux/gai-shu-he-huan-jing-an-zhuang/"/>
      <url>/2022/11/28/1-kai-fa/linux/gai-shu-he-huan-jing-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h3 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h3><p><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221002113558157-2074263708.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221002113558157-2074263708.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><p>linux Cent OS 7.6  [该版本已经不再维护]<br>地址：<a href="https://vault.centos.org/7.6.1810/isos/x86_64/">https://vault.centos.org/7.6.1810/isos/x86_64/</a> </p><h3 id="网络连接的三种方式"><a href="#网络连接的三种方式" class="headerlink" title="网络连接的三种方式"></a>网络连接的三种方式</h3><p>桥接模式：虚拟机有独立的ip，占用当前网段的ip<br>NAT地址转换模式：虚拟机通过主机代理向别的主机发送请求，不占用ip</p><p> <img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221002153240354-538715935.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221002153240354-538715935.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><strong>linux一切皆文件</strong><br>根目录  &#x2F;<br>bin  存放常用命令的具体实现，就是像 cd  tar等等<br>sbin superbin的意思，就是存放管理员才能使用的命令的具体实现<br>opt  一般存放安装包<br>home  存放每个用户的数据（用户名、密码等等），一个用户对应一个子文件夹，加入一个用户tom，那usr下就有一个子文件夹tom<br>     若使用命令 useradd jack 那就加了一个jack文件夹<br>ect  存放一些配置信息，用户配置 or 软件配置 ( mysql 账号密码？)<br>root 存放管理员用户的数据信息<br>boot 存放系统引导信息<br>usr  存放用户的应用程序和文件<br>     usr&#x2F;local 一般为软件安装的目录<br>mnt 挂载的文件系统 比如共享文件夹 D:&#x2F;myshare<br>var 存放不断扩大的东西，比如日志<br>tmp 存放临时文件<br>dev 存放设备信息，以文件的形式存储</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机视觉》 笔记</title>
      <link href="/2022/10/25/2-ji-suan-ji-shi-jue/ji-suan-ji-shi-jue-bi-ji/"/>
      <url>/2022/10/25/2-ji-suan-ji-shi-jue/ji-suan-ji-shi-jue-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="先验-后验-和-似然函数的关系"><a href="#先验-后验-和-似然函数的关系" class="headerlink" title="先验 后验 和 似然函数的关系"></a><a href="https://zhuanlan.zhihu.com/p/157677467">先验 后验 和 似然函数的关系</a></h3><h3 id="常见的概率分布模型"><a href="#常见的概率分布模型" class="headerlink" title="常见的概率分布模型"></a>常见的概率分布模型</h3><p>概率分布就是一个公式，给定X，就能计算出在这一点X的概率（或者连续随机变量的话就是这一点的概率密度）</p><p><em><strong>伯努利分布</strong></em><br>描述一个像素的灰度值大于或者小于128的概率<br>$$<br>P\left( x\ &#x3D;\ 0 \right) \ &#x3D;\ 1\ -\ \lambda \ \ \ \left( 0:\text{灰度值小于}128 \right)<br>$$<br>$$<br>P\left( x\ &#x3D;\ 1 \right) \ \ &#x3D;\ \lambda \ \left( 1:\text{灰度值大于}128 \right)<br>$$<br>$$<br>\text{或者统一为}<br>$$<br>$$<br>P\left( x \right) \ &#x3D;\ \lambda ^x\ *\ \left( 1-\lambda \right) ^{1-x}<br>$$</p><p><em><strong>贝塔分布</strong></em><br>一个连续的分布，<br>$\text{由单变量}\lambda \text{定义的连续分布，}\lambda &#x3D;\left[ 0,1 \right] ,\text{适合表示伯努利分布的参数}\lambda \text{的不确定性}$</p><p><em><strong>分类分布</strong></em><br>一个离散的分布，用来表示$k$个可能的结果的概率$\lambda _k$<br><em><strong>狄利克雷分布</strong></em><br>一个连续的分布，用于表示$k$个连续值($\lambda <em>{1…K}$)的取值情况，其中$\sum</em>{k&#x3D;1}^K{\lambda _k}&#x3D;1$，适合表示分类分布参数$\lambda _k$的分布</p><h3 id="拟合概率模型的方法——极大似然、最大后验、贝叶斯方法"><a href="#拟合概率模型的方法——极大似然、最大后验、贝叶斯方法" class="headerlink" title="拟合概率模型的方法——极大似然、最大后验、贝叶斯方法"></a>拟合概率模型的方法——极大似然、最大后验、贝叶斯方法</h3><p><em><strong>基本概念</strong></em><br>$<br>\text{先验\ }P\left( \theta \right) :\text{不考虑样本，这个分布的参数应该满足什么样的分布}<br>$<br>$<br>\text{后验\ }P\left( \theta |x \right) :\text{在已知样本}x\text{的结果的前提下，分布的参数是}\theta \text{的概率是多少}<br>$<br>$<br>\text{似然\ }P\left( x|\theta \right) :\ \text{好像就是实际的分布，就是说实际的分布的参数假如说是}\theta \ \text{的话，那么}x\text{的概率是啥}<br>$</p><h4 id="最大似然拟合概率模型-ML"><a href="#最大似然拟合概率模型-ML" class="headerlink" title="最大似然拟合概率模型 ML"></a>最大似然拟合概率模型 ML</h4><p>顾名思义就是说最大化 $P\left( x|\theta \right) &#x3D;P\left( x_{1..n}|\theta \right) &#x3D;\prod_{i&#x3D;1}^n{P\left( x_i|\theta \right)}$，求解其中的未知量$\theta$ </p><p>$$<br>\argmax_{\theta}P\left( x|\theta \right)<br>$$<br>$$<br>&#x3D;\argmax_{\theta}P\left( x_{1..n}|\theta \right)<br>$$<br>$$<br>&#x3D;\argmax_{\theta}\prod_i^n{P\left( x_i|\theta \right)}<br>$$<br>$$<br>&#x3D;\argmax_{\theta}\ \sum{\log \left( P\left( x_i|\theta \right) \right)}<br>$$</p><h4 id="最大后验拟合概率模型-MAP"><a href="#最大后验拟合概率模型-MAP" class="headerlink" title="最大后验拟合概率模型 MAP"></a>最大后验拟合概率模型 MAP</h4><p>顾名思义就是最大化后验<br>$$<br>\argmax_{\theta}P\left( \theta |x \right)<br>$$<br>$$<br>&#x3D;\argmax_{\theta}\frac{P\left( x|\theta \right) \ \times \ P\left( \theta \right)}{P\left( x \right)}<br>$$<br>$$<br>&#x3D;\argmax_{\theta}P\left( x|\theta \right) \ *\ P\left( \theta \right)<br>$$</p><p>他有个好处就是可以利用到先验的知识，不像极大似然估计只知道用样本的数据进行拟合，这个还考虑到了先验的概率，但是先验的参数怎么确定呢，有利也有弊，后验方式是先验和极大似然方式的加权平均</p><h4 id="贝叶斯方式"><a href="#贝叶斯方式" class="headerlink" title="贝叶斯方式"></a>贝叶斯方式</h4><p>其实我们的最终目的不是求参数$\theta$,而是给定一个新数据$x^*$要计算$P(x^*|X _{1..I})$的概率 ($X _{1..I}$ 表示已有的抽样的数据) ，之前都是找出一个概率最大的$\theta$,其实这个$\theta$也满足一个分布，我们直接对他进行每个概率都给他乘上，然后加权一下就好了<br>$$<br>P\left( x^*|X _{1..I} \right) \ &#x3D;\ \int{P\left( x^*|\theta \right) \ *\ P\left( \theta |x \right) \ d\theta}<br>$$<br>贝叶斯方式去除了计算参数$\theta$的误差，更加合理</p><p><em><strong>小tip</strong></em>：<br><strong>正定矩阵</strong>： $\text{正定矩阵}\varSigma \text{满足：\ }Z^T<em>\ \Sigma \ </em>\ Z\ \text{恒为正}$<br>方差： 用来衡量单个随机变量的离散程度<br>协方差： 用来衡量两个随机变量的相似程度<br>协方差矩阵；用来衡量了 一个具有多个随机变量的 分布 的离散程度</p><h3 id="生成模型和判别模型"><a href="#生成模型和判别模型" class="headerlink" title="生成模型和判别模型"></a>生成模型和判别模型</h3><p><em><strong>判别模型</strong></em>： 比较简单直接计算 $P(w|x) 这里的w叫做全局状态(我理解就是y)$ 大概就是先估计一下w的分布，比如说在例子通过轮胎像素的个数，来估计车身的大小的样例中，w估计就是一元正态分布<br>$P(w|x,\theta) &#x3D; Norm_w[a + bx,\sigma^2] 这里的\theta就是一些需要确定得超参数，包括a,b,\sigma,所以只要求出\theta的估计值就可以进行推理(我立即的是预测)了。\<br>确定超参数有好多算法，比如可以用MAP算法求\argmax_{\theta}P\left( x|\theta \right) \ *\ P\left( \theta \right)$ </p><p><em><strong>生成模型</strong></em>：假如说是一个分类问题，就拟合分类为0的数据的模型，然后拟合分类为1的数据的模型，然后对于一个给定的数据，带入到两个模型，看看哪个概率打， 就属于哪个【这是w为离散的情况，好理解些】<br>【w连续的情况】 $要计算的是 P(x|w,\theta) 就是说在每一个全局状态w下，存在x这种数据的概率,通过样本{x_i,w_i} 可以计算出参数\theta从而求得P(x|w)&#x2F;&#x2F;<br>这种情况需要先预估w的分布，然后用现有的w_i样本去拟合这个分布，得到P(w) 这样就可以利用贝叶斯公式计算出后验P(w|x) &#x3D; P(x|w) * p(w) &#x2F; p(x)$</p>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《计算机视觉》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LSTM</title>
      <link href="/2022/10/20/2-ji-suan-ji-shi-jue/lstm/lstm/"/>
      <url>/2022/10/20/2-ji-suan-ji-shi-jue/lstm/lstm/</url>
      
        <content type="html"><![CDATA[<p>LSTM 又叫长 短时记忆神经网络，问了解决RNN不能处理 <code>从较长的前文中推断下一个单词的问题</code> 而提出的<br><code>从较长的前文中推断下一个单词的问题</code>比如：”I grew up in France… I speak fluent <em>French</em>.”不能从这句中推出French，因为中间隔了好多词</p><h4 id="遗忘门："><a href="#遗忘门：" class="headerlink" title="遗忘门："></a>遗忘门：</h4><p><img src="https://img2022.cnblogs.com/blog/2851436/202211/2851436-20221126212224503-712213887.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202211/2851436-20221126212224503-712213887.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h4 id="输入门："><a href="#输入门：" class="headerlink" title="输入门："></a>输入门：</h4><p><img src="https://img2022.cnblogs.com/blog/2851436/202211/2851436-20221126212311075-209010384.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202211/2851436-20221126212311075-209010384.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h4 id="想下一个cell的输出："><a href="#想下一个cell的输出：" class="headerlink" title="想下一个cell的输出："></a>想下一个cell的输出：</h4><p><img src="https://img2022.cnblogs.com/blog/2851436/202211/2851436-20221126212423984-1696402345.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202211/2851436-20221126212423984-1696402345.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><p><img src="https://img2022.cnblogs.com/blog/2851436/202211/2851436-20221126212440327-44970240.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202211/2851436-20221126212440327-44970240.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/#fn1">参考链接1</a><br><a href="https://zhuanlan.zhihu.com/p/84333843">中文版参考链接</a><br><a href="https://www.bilibili.com/video/BV1J94y1f7u5?p=28&vd_source=a25e4be5f25feef1532666f6ee51cce1">李宏毅RNN教程</a> </p>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 李宏毅笔记 </tag>
            
            <tag> LSTM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAN 李宏毅笔记</title>
      <link href="/2022/10/19/2-ji-suan-ji-shi-jue/gan/gan-gai-shu/"/>
      <url>/2022/10/19/2-ji-suan-ji-shi-jue/gan/gan-gai-shu/</url>
      
        <content type="html"><![CDATA[<p>GAN(Generative Adversarial Network) 生成对抗网络</p><h4 id="1-为什么要有这个东西？"><a href="#1-为什么要有这个东西？" class="headerlink" title="1. 为什么要有这个东西？"></a>1. 为什么要有这个东西？</h4><p>   为了解决相同输入x，不同输出y的情形,每一个输出都是对的，唯一可以知道的是他服从某一个分布。 </p><p>   李宏毅中的例子是根据游戏的前三帧，去预测下一帧，当前三帧游戏人物走到路口的时候，下一帧可能左拐也可能右拐，无法得到一个确切的输出，只能得到一个概率分布。<br>   也可以用于扩充样本。</p><h4 id="2-生成对抗网络是什么？"><a href="#2-生成对抗网络是什么？" class="headerlink" title="2. 生成对抗网络是什么？"></a>2. 生成对抗网络是什么？</h4><p>   一个生成对抗网络主要包含 生成器 + 判别器</p><ol><li><p><code>生成器(G)</code>的主要作用就是根据一个输入z（满足某个分布的向量）随机生成输出y（满足另一个分布）</p></li><li><p><code>判别器(D)</code>的主要作用是判断G的某一堆输出y_s与最终要生成的数据的相似程度 相似度越高打分越高</p></li><li><p>直观理解：</p><p>3.1 正常的network都是给定一个 x,得到一个 y, 记作<code>&#123;f(x) = y&#125;</code></p><p>3.2 这里为了使得给定一个x得到不同的y，同时再给定一个z1(满足某种简单的分布Z)，这样便成了 <code>f(x,z1) = y</code>。</p><p>3.3 因为z服从一个分布Z，那么y也服从一个分布Y，这样的话对于一个输入x得到的输出就是一个分布，而不是确定的值，等到预测的时候 给定x, 同时从Z分中随机选取一个z1，就能得到一个满足Y分布的结果</p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129161135195-2104431847.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129161135195-2104431847.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p></li></ol><h4 id="4-如何保证分布Y就是我们想要的-概率分布呢？"><a href="#4-如何保证分布Y就是我们想要的-概率分布呢？" class="headerlink" title="4. 如何保证分布Y就是我们想要的 概率分布呢？"></a>4. 如何保证分布Y就是我们想要的 概率分布呢？</h4><p>使用 判别器D 建立一个分类的network，他的输入是 生成器G 的输出，和我们已知的样本分布，输出是一个值，表示他和所需要生成的样本的差异程度，用这个值来表示 生成器G 表现好不好<br><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129165154824-1146175719.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129165154824-1146175719.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>   真正计算的时候： 从real_data (标签1) 和 generated_data(标签0) 中随机抽取出若干个输入network分类，设定loss使得real_data得分尽可能高，generated_data 的分尽可能低</p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129201624345-504111067.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129201624345-504111067.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>   同时可以从理论上推导这个 loss Function和 JS Diversion 是有关联的，直观理解也好理解，只有分布相似，差异小才难分，然后那个maxV才不会太大，所有Diversion越小，maxV越小【具体推导见GAN原paper：<a href="https://arxiv.org/abs/1406.2661">https://arxiv.org/abs/1406.2661</a> 】</p><h4 id="5-整体优化目标是什么，如何训练？"><a href="#5-整体优化目标是什么，如何训练？" class="headerlink" title="5. 整体优化目标是什么，如何训练？"></a>5. 整体优化目标是什么，如何训练？</h4><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129205011815-1057653954.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129205011815-1057653954.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h4 id="6-GAN-是很难train的，原因是什么？"><a href="#6-GAN-是很难train的，原因是什么？" class="headerlink" title="6. GAN 是很难train的，原因是什么？"></a>6. GAN 是很难train的，原因是什么？</h4><ol><li><p>真实数据和生成的数据的分布存在重合很难 （1.所有图像空间中动漫的分布很小很小，存在交集就更难了 2.即使分布存在交集，我们sample出来的点构成的分布未必存在交集）</p></li><li><p>JS Diversion的特性是只要没有重合那两个分布的距离就是固定的log2</p></li></ol><p>所以可以看出JS divergence 不好，后人改用了W distance（Wasserstein distance）来衡量两个分布之间的距离，它的定义是通过移动一个分</p><p>布P中的样本点使其满足另一个分布Q，所需要移动的最小距离就是W distance</p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129213001543-1442672159.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129213001543-1442672159.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><em><strong>6.1 那W distance 如何计算</strong></em></p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129214907059-345839759.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129214907059-345839759.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><em><strong>lipschitz 条件</strong></em></p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129215424056-2087370460.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129215424056-2087370460.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><em><strong>6.2 如何使得函数D满足上述条件</strong></em></p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129220105514-1144868367.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129220105514-1144868367.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h4 id="7-生成器-和-判别器-必须水平相当才能训练起来，怎么保证双方水平相当呢？"><a href="#7-生成器-和-判别器-必须水平相当才能训练起来，怎么保证双方水平相当呢？" class="headerlink" title="7. 生成器 和 判别器 必须水平相当才能训练起来，怎么保证双方水平相当呢？"></a>7. 生成器 和 判别器 必须水平相当才能训练起来，怎么保证双方水平相当呢？</h4><p>一些tip</p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129223448387-1713605195.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129223448387-1713605195.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h4 id="8-怎么评估一个GAN的好坏，评估其生成的图片的质量的好坏"><a href="#8-怎么评估一个GAN的好坏，评估其生成的图片的质量的好坏" class="headerlink" title="8. 怎么评估一个GAN的好坏，评估其生成的图片的质量的好坏"></a>8. 怎么评估一个GAN的好坏，评估其生成的图片的质量的好坏</h4><p><strong><strong>评估图像质量</strong></strong></p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129231650951-2123842083.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129231650951-2123842083.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><em><strong>评估图像多样性</strong></em></p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129231619137-1629877941.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129231619137-1629877941.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>   综合质量和多样性的话就是Inception Score</p><p><em><strong>这种评估手段无法检测出的一些问题</strong></em></p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129225216914-758335728.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129225216914-758335728.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h4 id="9-有条件生成对抗网络"><a href="#9-有条件生成对抗网络" class="headerlink" title="9. 有条件生成对抗网络"></a>9. 有条件生成对抗网络</h4><p><img src="https://img2023.cnblogs.com/blog/2851436/202212/2851436-20221201105722166-1866872542.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202212/2851436-20221201105722166-1866872542.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><em><strong>conditional GAN 的应用</strong></em></p><ol><li>文字产生图像–&gt; AI 绘图</li><li>图像长生图像–&gt; Pix2Pix 图像转换 与正常不同的是对于相同的输入可以产生不同的输出</li><li>语音产生图像</li><li>图像产生动图</li><li>…</li></ol><h4 id="10-几种常见的GAN"><a href="#10-几种常见的GAN" class="headerlink" title="10. 几种常见的GAN"></a>10. 几种常见的GAN</h4><ol><li>原生GAN</li><li>DCGAN：G 使用的是反向卷积网络（一维的输入变为二维的输出）</li><li>WGAN ： 改进了损失函数，解决了原本的损失函数难以敏感的反应两个不相交的分布的距离这一问题</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 李宏毅笔记 </tag>
            
            <tag> GAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵乘法中的梯度计算（反向传播常用）</title>
      <link href="/2022/10/07/2-ji-suan-ji-shi-jue/cnn/si-kao-ju-zhen-cheng-fa-de-ti-du-ji-suan-tui-dao-guo-cheng/"/>
      <url>/2022/10/07/2-ji-suan-ji-shi-jue/cnn/si-kao-ju-zhen-cheng-fa-de-ti-du-ji-suan-tui-dao-guo-cheng/</url>
      
        <content type="html"><![CDATA[<p>神经网络中的反向传播中的梯度计算一直是让我和头疼的问题，翻了好多资料，现在记录下自己目前的所得</p><ol start="0"><li><p>结论<br>$$<br>\text{设\ }y\ &#x3D;\ f\left( X\ <em>\ W \right) \ ,\ C&#x3D;X\ </em>\ W,\text{则有:}<br>$$<br>$$<br>\frac{\partial y}{\partial W_{i,j}}&#x3D;X^T\frac{\partial y}{\partial C}<br>$$<br>$$<br>\frac{\partial y}{\partial X_{i,j}}&#x3D;\frac{\partial y}{\partial C}W^T<br>$$</p></li><li><p><a href="https://www.cnblogs.com/milaohu/p/7337330.html?utm_source=itdadao&utm_medium=referral">转载自大佬笔记</a></p></li></ol><p><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221021155540030-886714468.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221021155540030-886714468.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><ol start="2"><li><p><a href="https://www.matrixcalculus.org/">一个可以计算梯度的在线工具</a><br>虽然现在我自己还没玩明白hhh，但是功能应该是很强大</p></li><li><p><a href="https://blog.csdn.net/m0_63238256/article/details/126632188">一个具体推导的例子</a></p></li></ol><hr><ol start="4"><li><p>更新一个更简单的方式：<br> 根据矩阵乘法反向推导更加简单</p><p> 比如 正向D &#x3D; X * W (X:  n * m   W: m * k  D:  n * k)<br> dD 的shape肯定和D一样<br> 同理，dW 的shape肯定是m * k,同时dw肯定有dD和X组成，那么根据矩阵乘法原理必须是 x.T.dot(dD)才行</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS231 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反向传播</title>
      <link href="/2022/10/05/2-ji-suan-ji-shi-jue/cnn/04-fan-xiang-chuan-bo/"/>
      <url>/2022/10/05/2-ji-suan-ji-shi-jue/cnn/04-fan-xiang-chuan-bo/</url>
      
        <content type="html"><![CDATA[<p>等后续补充</p>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷积和池化</title>
      <link href="/2022/10/05/2-ji-suan-ji-shi-jue/cnn/05-juan-ji-chi-hua/"/>
      <url>/2022/10/05/2-ji-suan-ji-shi-jue/cnn/05-juan-ji-chi-hua/</url>
      
        <content type="html"><![CDATA[<p>卷积 输入和输出的关系</p><p>输入 N * N * D    卷积核 K * K * D2 stride(步长)、pad（周围填充）<br>输出尺寸 &#x3D; ( N + 2 * pad - K ) &#x2F; stride + 1 </p><p><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221024164713580-84738276.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221024164713580-84738276.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>反卷积输入输出公式</p><p>pytorch 的反卷积公式：<br><img src="https://img2023.cnblogs.com/blog/2851436/202212/2851436-20221206225435318-1923273135.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202212/2851436-20221206225435318-1923273135.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>注一般取值：</p><p>output_padding  :   stride - 1<br>padding         :   (kernel_size - 1) &#x2F; 2 </p><p>查看源码可以发现：</p><ul><li>Input: :math:$(N, C_{in}, L_{in})$</li><li>Output: :math:$(N, C_{out}, L_{out})$ where<br>$$<br>  L_{out} &#x3D; (L_{in} - 1) \times \text{stride} - 2 \times \text{padding} + \text{dilation}<br>      \times (\text{kernel_size} - 1) + \text{output_padding} + 1</li></ul><p>$$<br>通常dilation &#x3D; 1 简化为：<br>$$<br>L_{out}&#x3D;\left( L_{in}-1 \right) \times \text{stride}-2\times \text{padding}+\text{kernel_size}+\text{output_padding}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS231 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>损失函数和优化</title>
      <link href="/2022/10/04/2-ji-suan-ji-shi-jue/cnn/03-sun-shi-han-shu-he-you-hua/"/>
      <url>/2022/10/04/2-ji-suan-ji-shi-jue/cnn/03-sun-shi-han-shu-he-you-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="损失函数作用"><a href="#损失函数作用" class="headerlink" title="损失函数作用"></a>损失函数作用</h3><p>损失函数是一个衡量预测值和真实值之间差异的函数<br><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015220021130-696525952.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015220021130-696525952.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>Li表示第 i 张图片，预测值的十个输出与真实值之间的差异</p><h4 id="1-hinge-损失函数-应用于SVM"><a href="#1-hinge-损失函数-应用于SVM" class="headerlink" title="1. hinge 损失函数(应用于SVM)"></a>1. hinge 损失函数(应用于SVM)</h4><ol><li>基本思想</li></ol><ul><li>理想的输出的结果 对应的真实标签的得分应该是很高的， 比其他所有类别都高出一定的阈值，这样才好，此时损失值为0</li><li>否则的话就要受到惩罚</li></ul><p><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015221024642-823893558.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015221024642-823893558.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ol start="2"><li><p>符号说明：Li表示第i张图片预测值(10个)与真实值产生的误差S 表示 输出的预测的得分，S_y_i表示输出的真实值对应的得分，S_j表示其他类别的得分</p></li><li><p>特性</p></li></ol><ul><li>最小为0（得分最高，且超出一定阈值），最大为无穷（得分为负无穷）</li><li>对结果的轻微扰动不敏感，如car类4.9时已经损失值为0，轻微改变仍是0</li><li>训练最开始时损失函数为 c-1 （c表示种类数，此例c&#x3D;10）{训练最开始W一般为0-1之前很小的均匀分布的值，第一次输出得到的打分也大概相等，这样c-1 次max(0,$s_j - s_{yi}$+1) &#x3D; c-1}</li><li>使得loss&#x3D;&#x3D;0的W不唯一，但根据奥斯卡姆剃刀原理，我们选取最简单的W，为此可以加上一些惩罚项（正则项）。损失函数变为<img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015223631767-95832827.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015223631767-95832827.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></li><li>如何衡量W简单与否呢?可以使用L1范数、L2范数等等</li></ul><ol><li>向量化实现<br><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015223331177-380895889.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015223331177-380895889.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></li></ol><h4 id="2-交叉熵损失函数（应用于Softmax-loss）"><a href="#2-交叉熵损失函数（应用于Softmax-loss）" class="headerlink" title="2. 交叉熵损失函数（应用于Softmax loss）"></a>2. 交叉熵损失函数（应用于Softmax loss）</h4><ol><li><p>基本思想<br>真实出现的一定是概率最大的，所以真实值对应的标签概率化后概率应该尽可能大<br><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015224350184-1972939571.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015224350184-1972939571.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p></li><li><p>计算过程<br><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015224453793-99163284.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015224453793-99163284.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p></li><li><p>特性</p></li></ol><ul><li>最小是0，最大是无穷</li><li>对打分的 小的扰动敏感</li><li>初始损失函数 -log(1&#x2F;c)&#x3D;log(c),c表示种类</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> 损失函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单分类器</title>
      <link href="/2022/10/03/2-ji-suan-ji-shi-jue/cnn/02-jian-dan-fen-lei-qi/"/>
      <url>/2022/10/03/2-ji-suan-ji-shi-jue/cnn/02-jian-dan-fen-lei-qi/</url>
      
        <content type="html"><![CDATA[<h3 id="最近邻算法"><a href="#最近邻算法" class="headerlink" title="最近邻算法"></a>最近邻算法</h3><ol><li>思想：</li></ol><ul><li>训练：只是记录下每个样本的位置和标签</li><li>预测：遍历每个点，看一下距离该点最近的样本点的标签是啥，那他就是哪一类</li><li></li></ul><h3 id="K近邻算法"><a href="#K近邻算法" class="headerlink" title="K近邻算法"></a>K近邻算法</h3><ol><li>思想：</li></ol><ul><li>训练：只是记录下每个样本的位置和标签</li><li>预测：遍历每个点，看一下距离该点最近的K个样本点的标签较多的是啥，那他就是哪一类，如果各类数量一样无法区分</li></ul><ol start="2"><li>实现</li></ol><ul><li>可以多使用模块化思想，数据输入、预处理和分类器模型分开来写，这样方便分类器的复用</li><li>向量化运算可以大大缩短循环所需的时间</li><li>np.sum(a,axis&#x3D;0) 假设a原本是2 × 3 × 4，对第一维求和后变为 3 × 4</li><li>np.sort(), np.argmin(a)找到a数组中最小的数的索引</li><li>numpy.array_split:将numpy数组分为n份，对于不整除的前面是 1 &#x2F;&#x2F; n + 1 ..后面是1 &#x2F;&#x2F; n</li><li>np.concatenate((a,b,c),axis &#x3D; 0) 将numpy数组a,b,c拼接</li></ul><p>训练完计算准确率常用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num_correct = np.<span class="built_in">sum</span>(y_test_pred == y_test)</span><br><span class="line">accuracy = <span class="built_in">float</span>(num_correct) / num_test</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Got %d / %d correct =&gt; accuracy: %f&#x27;</span> % (num_correct, num_test, accuracy))</span><br></pre></td></tr></table></figure><h3 id="线性分类器"><a href="#线性分类器" class="headerlink" title="线性分类器"></a>线性分类器</h3><p>类似于模板匹配<br>CIFAR10 图片分类任务，是个很经典的数据集，图片大小是 <code>32*32*3</code> , 类别是十类<br><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015214914968-516055086.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015214914968-516055086.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>输入 1*3072的数据  输出十个数（表示十各类的得分）<br>F(x,W) &#x3D; Wx + b,就是要找一些数能够使得图片x所对应的标签得分更高<br><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015215106537-457567375.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015215106537-457567375.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><br>将W可视化后也可以看到大概W就是每类图片的一个公共的特征</p><p>现在只是有了一个打分，但是如何衡量这个打分的好坏，需要量化，我们把这个评价其打分好坏的量化函数叫做<strong>损失函数</strong></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li><p>关于划分训练集和测试集</p><ol><li>比较好的思路是划分训练集+验证集+测试集，然后用训练集训练，通过验证集调节超参，调到最好的超参后在测试集上测试准确率，这样的话在模型调节完之前一直接触不到测试集，测试集才能更加好的拟合数据集之外的真实数据</li><li>还有一个思路<em><strong>K折交叉验证</strong></em>，意思是划分为训练集 + 测试集，但是训练集划分为K份，用其中的K-1份进行训练，1份用作验证集调参。（一般用于数据较少的时候，少于一万条？)</li></ol></li><li><p>关于调节超参<br>最好有一个随着超参的每一个值变化，模型准确率变化的图，这样能够更好的描述该参数最好的取值是多少</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS231 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNN 概述</title>
      <link href="/2022/10/02/2-ji-suan-ji-shi-jue/cnn/01-gai-shu/"/>
      <url>/2022/10/02/2-ji-suan-ji-shi-jue/cnn/01-gai-shu/</url>
      
        <content type="html"><![CDATA[<p>斯坦福CS231 视频 </p><p><a href="https://www.bilibili.com/video/BV1nJ411z7fe/?spm_id_from=333.999.0.0&vd_source=a25e4be5f25feef1532666f6ee51cce1">视频</a><br><a href="https://cs231n.github.io/">作业笔记</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h3><ol><li>计算机视觉很火 随着传感器(摄像头的的增多）网上80%都是视频</li><li>视频理解很难：可以类比物理学中的暗物质，占据宇宙（网络）中绝大部分，但是很难理解</li><li>比较直观的应用就是短视频平台中需要对用户上传的视频进行分类（好、坏 or 进一步分为搞笑、科普、测评、商务等等）</li><li>2012年 ImageNet 大规模图像分类挑战赛上，CNN第一次崭露头角，将错误率从 26% 降到 16%，人脸检测从2001年的Adabost就开始了，效果还不错</li><li>最厉害的境界是对场景的理解</li></ol><h3 id="研究的问题"><a href="#研究的问题" class="headerlink" title="研究的问题"></a>研究的问题</h3><ol><li>图像分类</li><li>目标检测</li><li>图像分割</li><li>图像摘要</li><li>医疗诊断</li><li>自动驾驶</li></ol><h3 id="Python和Numpy基础教程"><a href="#Python和Numpy基础教程" class="headerlink" title="Python和Numpy基础教程"></a><a href="https://cs231n.github.io/python-numpy-tutorial/">Python和Numpy基础教程</a></h3><p><em><strong>Python</strong></em></p><ol><li>列表表达式 <code>even_squares = [x ** 2 for x in nums if x % 2 == 0]</code></li><li>输入输出 <code>a=int(input(&quot;请输入一个整数&quot;))</code>  <code>print(bin(7),bin(15),&#39;以上两位按位与之后&#39;,7&amp;15)</code></li><li>循环<br><code>for i in range(2,a//2+1):</code><br><code>for idx, animal in enumerate(animals):</code> &#x2F;&#x2F;带索引的循环</li></ol><hr><p><em><strong>Numpy</strong></em></p><ol><li>Matrix *   <code>a.dot(b)</code> or <code>np.dot(a,b)</code></li><li>点乘（对应位置相乘）  a * b</li><li>求矩阵每一列的和  <code>np.sum(x, axis=0)</code></li><li>矩阵转置 <code>V.T</code></li><li><a href="https://numpy.org/doc/stable/user/basics.broadcasting.html">关于广播</a>:会从后往前扫描每一个维度，要么相同，要么有一方维度是1，可以广播此维度</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS231 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy 技巧</title>
      <link href="/2022/10/01/2-ji-suan-ji-shi-jue/cnn/00numpy-ji-qiao/"/>
      <url>/2022/10/01/2-ji-suan-ji-shi-jue/cnn/00numpy-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h3 id="构造列表筛选功能"><a href="#构造列表筛选功能" class="headerlink" title="构造列表筛选功能"></a>构造列表筛选功能</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array(<span class="built_in">range</span>(<span class="number">6</span>)).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">mask = np.array([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组\n&#x27;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;筛选数组&#x27;</span>,mask)</span><br></pre></td></tr></table></figure><p>原数组<br>    [[0 1 2]<br>    [3 4 5]]<br>筛选数组 [1 2]</p><h4 id="要求实现"><a href="#要求实现" class="headerlink" title="要求实现"></a>要求实现</h4><p>筛选出原数组，第i行的第mask[i]个元素</p><ol><li>循环实现</li><li>向量实现</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 循环实现</span></span><br><span class="line">b=[]</span><br><span class="line"><span class="keyword">for</span> idx,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(mask):</span><br><span class="line">    b.append(a[idx,x])</span><br><span class="line">np.array(b)</span><br></pre></td></tr></table></figure><pre><code>array([1, 5])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 向量实现</span></span><br><span class="line">a[<span class="built_in">range</span>(<span class="built_in">len</span>(mask)),mask]</span><br></pre></td></tr></table></figure><pre><code>array([1, 5])</code></pre><h3 id="Numpy-一百题"><a href="#Numpy-一百题" class="headerlink" title="Numpy 一百题"></a><a href="https://github.com/rougier/numpy-100">Numpy 一百题</a></h3><p>以下为笔记</p><ol><li>数组逆序 <code>Z[::-1]</code> ：取自缩写 of Z[1:10:2]</li><li>查找非0元素的下标  np.nonzero([1,2,3,0,3,0]) </li><li>创建 3 * 3 的单位矩阵 np.eye(3)</li><li>创建 3 * 3 * 3 的随机数矩阵 np.random.random((3,3,3))</li><li>数组周围增加一个边界 np.pad(Z, pad_width&#x3D;1, mode&#x3D;’constant’, constant_values&#x3D;0)</li><li>print(0.3 &#x3D;&#x3D; 3 * 0.1) # False<br>print(0 * np.nan) # np.nan<br>print(np.inf &gt; np.nan) #False</li><li>numpy.diag(v, k&#x3D;0): v 是 2d 则提取对角线元素，v是1d则构建对角矩阵 ， k&#x3D;1 表示主对角线上边一行，k&#x3D;-1表示对角线下面一行</li><li>输出棋盘样式的矩阵<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Z = np.ones((<span class="number">8</span>,<span class="number">8</span>),dtype=<span class="string">&#x27;int&#x27;</span>)</span><br><span class="line">Z[:-<span class="number">1</span>:<span class="number">2</span>,<span class="number">0</span>:-<span class="number">1</span>:<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">Z[<span class="number">1</span>::<span class="number">2</span>,<span class="number">1</span>::<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line">answer(<span class="number">19</span>)</span><br><span class="line">--------------------------</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]]</span><br></pre></td></tr></table></figure></li><li>矩阵乘法（真矩阵相乘） <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(X.dot(Y))</span><br><span class="line"><span class="built_in">print</span>(X @ Y)</span><br></pre></td></tr></table></figure></li><li>有一种简写  <code>np.array(range(10))  ---&gt;  np.arange(10)</code></li><li>numpy数组中筛选出 3 到 8 的数值  <code>X[ (X&gt;=3) &amp; (X&lt;=8)]</code></li><li>有趣的题<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">5</span>),-<span class="number">1</span>)) <span class="comment"># 输出 9   这里-1 的意思是前面的和加上一个start值，此处start=-1</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">5</span>),-<span class="number">1</span>)) <span class="comment"># 输出 10  这里-1 的意思是默认对最低维度求和</span></span><br></pre></td></tr></table></figure></li><li>四舍五入 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Y = np.ceil(X)</span><br><span class="line">Z = np.floor(X)</span><br><span class="line">T = np.<span class="built_in">round</span>(X)</span><br></pre></td></tr></table></figure></li><li>找两个数组的交集 <code>np.intersect1d(Z1,Z2)</code></li><li>获得日期的函数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yesterday = np.datetime64(<span class="string">&#x27;today&#x27;</span>) - np.timedelta64(<span class="number">1</span>)</span><br><span class="line">today     = np.datetime64(<span class="string">&#x27;today&#x27;</span>)</span><br><span class="line">tomorrow  = np.datetime64(<span class="string">&#x27;today&#x27;</span>) + np.timedelta64(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li>创建一个5*5的矩阵，每一行都是0-4<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X = np.zeros((<span class="number">5</span>,<span class="number">5</span>),dtype=<span class="built_in">int</span>)</span><br><span class="line">Y = X + np.arange(<span class="number">5</span>)</span><br><span class="line">&lt;!-- ----------- --&gt;</span><br><span class="line">X = np.arange(<span class="number">5</span>)</span><br><span class="line">Y = np.tile(X,(<span class="number">5</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure></li><li>创建10个数线性分布在0-1之间，不包括0、1 <code>Z = np.linspace(0,1,11,endpoint=False)[1:]</code></li><li>随机从1-n个数中选m个<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n , m = <span class="number">25</span>,<span class="number">5</span></span><br><span class="line">np.random.choice(np.arange(<span class="number">1</span>,n+<span class="number">1</span>),m)<span class="comment">#从1 ~ n+1随机选m个</span></span><br><span class="line">np.random.choice(n,m) <span class="comment">#从0~n随机选m个</span></span><br></pre></td></tr></table></figure></li><li>随机从给定区间内抽数，保证等概率 np.random.uniform(a,b,c) 在区间[a,b)内等概率抽取c个，特殊情况下a&#x3D;0,b&#x3D;1时等价于random.random(c),想要整数可以使用np.random.randint</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS231 </tag>
            
            <tag> CNN </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 入门</title>
      <link href="/2022/09/01/1-kai-fa/git/git-ru-men/"/>
      <url>/2022/09/01/1-kai-fa/git/git-ru-men/</url>
      
        <content type="html"><![CDATA[<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p> <code>git status</code> 当前仓库的状态</p><p><code>git add &quot;filename.txt&quot;</code>向暂存区添加文件</p><p><code>git commit -m &quot;描述语句&quot;</code>提交暂存区文件</p><p><code>git diff</code>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p><p><code>git log</code>显示该仓库所有提交记录，简洁版是<code>git log --pretty=oneline</code></p><h4 id="时空穿梭"><a href="#时空穿梭" class="headerlink" title="时空穿梭"></a>时空穿梭</h4><ul><li>回到过去</li></ul><ol><li><code>git reset --hard HEAD^</code>回退到上一个版本</li><li><code>git log</code> 查看过去提交的版本号id，然后用<code>git reset --hard id</code>即可</li></ol><ul><li>重返未来</li></ul><ol><li><code>git reflog</code> 查看命令历史，看到未来的版本号id，然后使用<code>git reset --hard id</code>重返未来</li></ol><h4 id="Git管理的文件分为"><a href="#Git管理的文件分为" class="headerlink" title="Git管理的文件分为"></a>Git管理的文件分为</h4><ul><li><p>工作区</p></li><li><p>版本库，</p><ul><li>暂存区stage</li><li>暂存区分支master(仓库)</li></ul></li></ul><p><code>git add</code>把文件从工作区&gt;&gt;&gt;&gt;暂存区，<code>git commit</code>把文件从暂存区&gt;&gt;&gt;&gt;仓库，</p><p><strong>git diff 三件套</strong></p><p><code>git diff</code>查看工作区和暂存区差异</p><p><code>git diff --cached</code>查看暂存区和仓库差异，</p><p><code>git diff HEAD</code> 查看工作区和仓库的差异，</p><p><strong>注</strong> : 暂存区为空使用git diff：因为此时暂存区为空，此时使</p><p>用git diff同样也是比较工作区和仓库，即和使用git diff HEAD结果相同</p><p><strong>文件传输</strong></p><p><code>git add</code>的反向命令<code>git checkout</code> – file，撤销工作区修改，即把暂存区（若空则为仓库）最新版本转移到工作区，</p><p><code>git commit</code>的反向命令<code>git reset HEAD &lt;file&gt;</code>，就是把仓库最新版本转移到暂存区。</p><p>删除文件 <code>git rm file</code>然后<code>git commit -m &quot;remove file&quot;</code></p><p>最最常用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">新建文件，或者修改后</span><br><span class="line">git add . //将所有的修改提交到暂存区</span><br><span class="line">git commit -m &quot;版本提交注释&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ssh-keygen -R 20.205.243.166</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
