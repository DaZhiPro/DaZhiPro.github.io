<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Date Augmentation Using GANs文献阅读笔记</title>
      <link href="/2023/02/06/2-ji-suan-ji-shi-jue/gan/data-augmentation-using-gans/"/>
      <url>/2023/02/06/2-ji-suan-ji-shi-jue/gan/data-augmentation-using-gans/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><ul><li>样本不均衡问题<ul><li>信用卡欺诈分类： 正常：欺诈=10000:1</li></ul></li><li>敏感数据脱敏问题<ul><li>某些医疗数据即时隐去姓名，还是有身高、体重等敏感信息，不能完全脱敏</li></ul></li></ul><h2 id="主要内容"><a class="markdownIt-Anchor" href="#主要内容"></a> 主要内容</h2><p>用GAN进行数据增强解决上述两个问题</p><ul><li>对于问题一使用GAN扩充样本少的类别，可避免过拟合问题，求得的分类模型更加准确<ul><li>与两个现有的解决样本不均衡问题的方法SMOTE和ADASYN做对比</li></ul></li><li>对于问题二使用初始敏感数据产生合成数据，合成数据既不是真实数据，不再敏感，同时又保留了样本的真实特征<ul><li>初始数据 使用决策树分类，用GAN产生的合成数据使用决策树分类二者对比，发现效果一样甚至还优于原始数据</li></ul></li></ul><h3 id="gan"><a class="markdownIt-Anchor" href="#gan"></a> GAN</h3><p>缺点： 很难train、需要很大的运算能力、不稳定、可能回过拟合</p><h3 id="两个过采样方法-smote-和-adasyn"><a class="markdownIt-Anchor" href="#两个过采样方法-smote-和-adasyn"></a> 两个过采样方法 SMOTE 和 ADASYN</h3><p>Synthetic Minority Over sampling Technique (SMOTE)：合成少数过采样技术<img src="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230206205312157-2130737129.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230206205312157-2130737129.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><p>ADASYN：由SMOTE技术演变而来，就是原本新产生点是直接取中间值（某一个百分比值）改成了取中间值 + 一个偏移量</p><h2 id="实验设计"><a class="markdownIt-Anchor" href="#实验设计"></a> 实验设计</h2><ul><li><p>实验二：分别通过GAN、SMOTE、ADASYN三种方式扩充不平衡样本中的 小样本数据，然后看分类器的性能，其中不进行小样本扩充的原始数据集作为baseline</p></li><li><p>实验一：对比原始数据集 和 不同 GAN 结构产生的fake数据集，目的是让这两个数据集上的分类器性能尽可能一致，这样以后需要训练一个模型，直接在fake数据集上训练就好了，从而解决数据脱敏问题</p></li></ul><h3 id="数据集问题"><a class="markdownIt-Anchor" href="#数据集问题"></a> 数据集问题</h3><p>总共有三个数据集</p><ol><li>糖尿病</li><li>乳腺癌</li><li>信用卡欺诈<img src="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230206214722087-1266128524.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230206214722087-1266128524.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></li></ol><h3 id="六种不同的-gan-结构"><a class="markdownIt-Anchor" href="#六种不同的-gan-结构"></a> 六种不同的 GAN 结构</h3><p>不同的GAN结构和它产生的数据集的命名<img src="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230206214822755-1982019796.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230206214822755-1982019796.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><h3 id="实验一-完全用gan产生的数据集对糖尿病和癌症数据集进行分类"><a class="markdownIt-Anchor" href="#实验一-完全用gan产生的数据集对糖尿病和癌症数据集进行分类"></a> 实验一 完全用GAN产生的数据集对<em>糖尿病和癌症</em>数据集进行分类</h3><p>Experiment 1: Training the classifier using fully synthetic dataTo evaluate the creation of synthetic data the experiments were done using the followingsteps:</p><ol><li>Trained the GAN using the full training subset of the original database for 1500epochs.</li><li>Used the newly trained GAN to generate a new synthetic data set with the exact sizeof the original.</li><li>Since the GANs generated the classification label as a continuous value between 0 and1, this value has to be turned to a discrete by rounding it to the nearest integer.</li><li>The new data set is used to train a classification tree.</li><li>The tree is tested using the test subset of the original data set.</li></ol><p><img src="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230207103815477-1503149782.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230207103815477-1503149782.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><h4 id="结果分析"><a class="markdownIt-Anchor" href="#结果分析"></a> 结果分析</h4><ol><li><p>某些<em><strong>属性</strong></em>下 产生的数据集和原始数据集的<em><strong>对比</strong></em><img src="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230207101331964-1557115178.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230207101331964-1557115178.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p></li><li><p><em><strong>癌症数据集的准确率</strong></em><img src="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230207101529852-626268011.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230207101529852-626268011.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p></li><li><p><em><strong>糖尿病数据集的准确率</strong></em><img src="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230207101557532-137282506.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230207101557532-137282506.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p></li><li><p>具体来说,准确度上来说癌症数据集中GAN产生的合成数据优于原始数据，糖尿病数据集GAN产生的合成数据接近原始数据，召回率上来说癌症数据集中GAN产生的合成数据接近于原始数据，糖尿病数据集GAN产生的合成数据优于原始数据，，总体来书256/512GAN结构产生的合成数据集可以代替原始数据集，同时产生的数据集和原始数据集的欧氏距离不小，不存在根据合成数据集推断出原始数据集中病人敏感信息的可能，所以GAN用于脱敏是可行的</p></li></ol><p>注：在对医学数据进行分类时，我们更感兴趣的是召回率，而不是准确性，因为在决定患者是否需要治疗或进行某种诊断时，假阴性可能是灾难性的</p><h3 id="实验二-对比扩充不平衡数据集-用三种不同的方式gan-smote-adasyn"><a class="markdownIt-Anchor" href="#实验二-对比扩充不平衡数据集-用三种不同的方式gan-smote-adasyn"></a> 实验二 对比扩充不平衡数据集 用三种不同的方式GAN、SMOTE、ADASYN</h3><ol><li>Separated the training set based on the target class (For example, the credit carddatabase was separated in non-frauds and frauds).</li><li>Trained the GAN using only the minority class data. The label was included as anattribute in the training.</li><li>Used the GAN to add new entries to the training data set until it becomes balanced.</li><li>Used the newly balanced training data set to train the classifier.</li><li>The classifier was tested on two databases: the original test set and a balanced versionof it obtained by undersampling the majority class.</li></ol><p><img src="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230207171302043-1420549164.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230207171302043-1420549164.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><p><a href="https://excalidraw.com/#json=NXZoGimteRBJj700IK7YI,o6vAua82rHVRPutLOTRRBg">原图链接</a></p><h4 id="结果分析-2"><a class="markdownIt-Anchor" href="#结果分析-2"></a> 结果分析</h4><ol><li><p>不平衡数据集上的测试结果<img src="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230207171808661-884420257.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230207171808661-884420257.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Classification results from testing on the imbalanced test set" /></p></li><li><p>平衡数据集上的测试结果<img src="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230207171927650-299671969.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230207171927650-299671969.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p></li><li><p>在不平衡数据集上应用 GAN、SMOTE、ADASYN 扩充少数样本都比不扩充强， GAN的方式扩充比其他两种方式能够获得更高的准确率和精确度（查准率），但是召回率（查全率）不如其他两种方式，欺诈检测的话更关注于检测出所有少出样本，所以更关注召回率（查全率），所以在这一方面，所列出的这六种GAN的结构是弱于 SMOTE和ADASYN的</p></li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>总体来说，文章讲述了GAN的两大基本应用，一个是通过 GAN 在没有原始数据集的情况下可以训练一个分类器（解决敏感数据脱敏的问题，另一个是通过 GAN 扩充少数样本来解决样本不均衡的问题、最终发现使用GAN合成的数据训练出来的分类器性能甚至更好，第一个方面对于数据脱敏问题有个很好的应用在处理样本不均衡的问题上，使用GAN扩充少数样本比不扩充效果更好，但是不如SMOTE 和 ADASYN ，好处是比较简单，不需要定义任何约束和规则最后本文知识研究了GAN基本架构，探讨了不同深度的变化，后续可以进行过更多研究</p><ol><li>优点：这篇论文的特别之处就是他并没有用 loss 有多低，有多接近样本去描述GAN的好坏，他直接用了简单的分类器，对比GAN产生的数据和原始数据上两个分类器性能的好坏，来评价GAN的好坏。某种意义上说可能 GAN 产生的数据在我们看来不太一样，但是在在计算机看来就是一样的，而且分类器性能更好，说明可能 GAN 抓住了本质，本质（某些特征）上一样，知识我们乍一看可能不一样</li><li>缺点：文章中所实验的GAN的网络结构比较简单，可以使用不同的loss探索更多的可能。</li></ol><h4 id="补充知识"><a class="markdownIt-Anchor" href="#补充知识"></a> 补充知识</h4><p>TP（True Positives)：真正例，预测为正例而且实际上也是正例；</p><p>FP（False Positives)：假正例，预测为正例然而实际上却是负例；</p><p>FN（false Negatives)：假负例，预测为负例然而实际上却是正例；</p><p>TN（True Negatives)：真负例，预测为负例而且实际上也是负例。</p><p><img src="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230207163510581-1103619479.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230207163510581-1103619479.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><p>准确率：预测对的占比</p><p>精确率（查准率）：在预测为正的样本中，实际是正样本的概率</p><p>召回率：在实际的正样本中，预测为正样本的概率</p><p>F1值：综合考虑精确率和召回率具体参考链接 <a href="https://blog.csdn.net/lhxez6868/article/details/108150777">https://blog.csdn.net/lhxez6868/article/details/108150777</a></p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p>原文献：<a href="https://arxiv.org/pdf/1904.09135.pdf">https://arxiv.org/pdf/1904.09135.pdf</a>代码：  <a href="https://github.com/fhtanaka/directed_research_CS_2018">https://github.com/fhtanaka/directed_research_CS_2018</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
            <tag> GAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>历史记</title>
      <link href="/2023/02/04/4-ri-chang-sui-bi/li-shi-ji/"/>
      <url>/2023/02/04/4-ri-chang-sui-bi/li-shi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230204214028069-1851074439.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230204214028069-1851074439.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p>]]></content>
      
      
      <categories>
          
          <category> 日常随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 历史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设题目及规划</title>
      <link href="/2023/02/02/2-ji-suan-ji-shi-jue/bi-she/bi-she-gui-hua/"/>
      <url>/2023/02/02/2-ji-suan-ji-shi-jue/bi-she/bi-she-gui-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>题目：基于深度学习的超声波流量计量性能评估系统设计</p><p>本课题旨在设计实现一个基于深度学习的超声波流量计计量性能评估系统，目的是通过深度生成对抗网络</p><p>（1）流量检测模块，通过可视化的图表将收集到的<strong>流量计<em>各声道</em>流速数据和总流速数据</strong>进行展示，让现场检定人员能够直观观测到流量计计量的动态变化。</p><p>（2）数据收集与预处理模块，收集压力、温度、流量计声道数据，对数据进行预处理，方便后续评估模型对数据的处理。</p><p>（3）模型训练模块，分析流量计相关数据的特征，选择相应的深度学习方法进行数据的训练和特征提取，并进行算法优化，最终得出训练较优的流量计性能评估模型。</p><p>（4）性能在线评估模块，利用训练好的性能评估模型对流量计检定过程产生的数据进行评估，识别流量计计量性能偏差，给出对实际流量的预测和流量计计量偏差值。</p><p>实验环境：自选。</p><h2 id="具体步骤"><a class="markdownIt-Anchor" href="#具体步骤"></a> 具体步骤</h2><h4 id="大概分为三步"><a class="markdownIt-Anchor" href="#大概分为三步"></a> 大概分为三步</h4><p>数据集的样子大概就是        多维输入 一维输出</p><ol><li>扩充数据集： 可以用GAN，也可以尝试一下其他的，比如VAE</li><li>挑选合适的回归模型</li><li>做一个可视化界面 界面可以设置一些参数，然后后台训练，界面可以输入数据，进行预测</li></ol><h4 id="现在要做的"><a class="markdownIt-Anchor" href="#现在要做的"></a> 现在要做的</h4><p>学习基本的GAN网络结构，找个小点的数据集，测试一下，用GAN去扩充一下学习一些常用的回归模型，准备好代码做一个简单的可视化界面学习一下基本的机器学习      书籍《统计学习方法》有时间学一下优化方面的知识  书籍《最优化导论》</p><h4 id="一些小的idea"><a class="markdownIt-Anchor" href="#一些小的idea"></a> 一些小的idea</h4><ol><li><p>对于步骤2：研究物理过程，考虑最复杂的情况下可能的公式，然后可能有几十个未知参数，构造一个前向传播就是这个公式的神经网络，通过反向传播使得loss最小来求得参数</p></li><li><p>对于步骤1：使用GAN的两种方式：</p><ol><li><p>扩充样本数据<img src="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230201112002921-745760998.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230201112002921-745760998.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p></li><li><p>直接应用GAN当做网络模型<img src="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230201112252507-983612410.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230201112252507-983612410.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" />例子：根据带噪声信号产生降噪声信号<img src="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230201112428999-530096738.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202302/2851436-20230201112428999-530096738.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p></li></ol></li></ol><h4 id="背景知识"><a class="markdownIt-Anchor" href="#背景知识"></a> 背景知识</h4><p><em><strong>超声波流量计</strong></em>超声波流量计是通过利用超声波于流体之中传播时将会被流体流动影响的这种现 象来进行工作的。流量计是通过在流体里进行超声波信号的发送，当超声波在流体里进 行传播的时候会将测量流体的流速等一系列信息，与此同时对超声波回波信号进行检测 以及处理的方式就能够得到流体的流速</p><p>分类：多普勒法计算流速：多普勒超声波流量计多普勒效应：假如两个物件之间的相对间距在降低，接受的频率将比原先强化。假如两个物件之间的相对间距在增加，接受的频率便会比原先降低</p><p>传播时间计算流速：时差法、相差法、频差法</p><p>时差法<img src="https://img2023.cnblogs.com/blog/2851436/202301/2851436-20230129145717771-861189124.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202301/2851436-20230129145717771-861189124.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" />···</p>]]></content>
      
      
      <categories>
          
          <category> 毕设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
            <tag> 样本扩充 </tag>
            
            <tag> 回归拟合 </tag>
            
            <tag> 界面开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机视觉》 笔记</title>
      <link href="/2023/01/30/2-ji-suan-ji-shi-jue/hui-gui-mo-xing/"/>
      <url>/2023/01/30/2-ji-suan-ji-shi-jue/hui-gui-mo-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="第八章-回归模型"><a class="markdownIt-Anchor" href="#第八章-回归模型"></a> 第八章 回归模型</h1><p>定义：根据向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><msup><mo stretchy="false">]</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">x = [x_1,x_2,...,x_n]^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 来估计全局状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>，就是说计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>w</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(w|x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></p><h2 id="线性回归"><a class="markdownIt-Anchor" href="#线性回归"></a> 线性回归</h2><ol><li>设 w 满足的概率分布，一般连续的就设 一元正态分布（离散的就设分类分布），这样的话只需要求出分布的参数，就能求某一个 w 的概率，但是还要和我们的数据扯上关系，所以 就设正态分布的参数 u 为数据 x 的线性函数 (u = <em>ax</em> + b，此时引入了超参 <em>a</em>,b)</li><li>只需要计算出参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>（包括a,b,方差） 就能完美的描述数据 x 和 全局状态 w 之间的关系</li><li>使用极大似然估计方法 使得似然 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>w</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo separator="true">,</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(w|x,\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span> 最大</li></ol><p>![img](<a href="https://img2023.cnblogs.com/blog/2851436/202301/2851436-20230131111542071-1844025411.png">https://img2023.cnblogs.com/blog/2851436/202301/2851436-20230131111542071-1844025411.png</a> =500x)</p><h2 id="贝叶斯回归"><a class="markdownIt-Anchor" href="#贝叶斯回归"></a> 贝叶斯回归</h2><p>正常是求最优的参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>,然后用这个参数直接求新数据的预测概率，贝叶斯方法是直接求参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>的概率分布，然后预测的时候对它的每个可能的取值进行加权求和</p><h2 id="非线性回归"><a class="markdownIt-Anchor" href="#非线性回归"></a> 非线性回归</h2><h2 id="稀疏线性回归"><a class="markdownIt-Anchor" href="#稀疏线性回归"></a> 稀疏线性回归</h2>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《计算机视觉》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数问题</title>
      <link href="/2023/01/17/3-suan-fa/dong-tai-gui-hua/ji-shu-wen-ti/"/>
      <url>/2023/01/17/3-suan-fa/dong-tai-gui-hua/ji-shu-wen-ti/</url>
      
        <content type="html"><![CDATA[<h4 id="计数问题"><a class="markdownIt-Anchor" href="#计数问题"></a> <a href="https://www.acwing.com/problem/content/340/">计数问题</a></h4><h4 id="基本思路"><a class="markdownIt-Anchor" href="#基本思路"></a> 基本思路：</h4><ol><li>暴力(O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>1</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>)) 暴力遍历每一个数，然后遍历每一位 这样的话 复杂度 1e8 * 8 * 测试样例数 大概就是 1e9 左右，但是C++代码中的操作次数控制在 1e7 ~ 1e8</li><li>数位dp进行优化首先设定一个函数 <code>count(int n, int x)</code> 用于计算 1 ~ n 中 x 出现的次数然后分类讨论对于任意一个数 abcdefg  x 出现在第 i 位可能的情况数有多少例如 i = 4： *** x ***</li><li>前三个数 *** 取 000 ~ abc - 1 的时候，第四位是 x，此后三位随便取 000~999 共1e3中取法, 组合共 abc *   1e3种取法</li><li>前三个数 *** 取 abc 时候，<ol><li>第四位取 x 且 x = d 时，此后三位数取 000~efg 共 efg + 1 种情况</li><li>第四位取 x 且 x &lt; d 时，此后三位随便取 000~999 共 1e3 中取法</li></ol></li></ol><p>前导0的问题：(1) 0 不可能出现在 最高位，x = 0时不用考虑最高位是x的情况(2) x = 0时，前面的数不能全为0，例如 i = 4，第四位是x，是0 的时候，他前面不能是 <code>000~abc-1</code>，必须是<code>001~abc-1</code></p><h4 id="具体算法"><a class="markdownIt-Anchor" href="#具体算法"></a> 具体算法：</h4><p>遍历n的每一位，考虑第i位为x的情况共有多少种， 种类数就是前面讨论为三类之和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i in each n:</span><br><span class="line">    ans += <span class="built_in">get</span>(nums,<span class="number">0</span>,i<span class="number">-1</span>) * <span class="number">10</span> ^ (n - <span class="number">1</span> - i) <span class="comment">// 第一种 *** 取 0 ~ abc</span></span><br><span class="line">    <span class="keyword">if</span>(nums[i] == x) ans += <span class="built_in">get</span>(nums,i + <span class="number">1</span>, n - <span class="number">1</span>) + <span class="number">1</span> <span class="comment">//第二种2.1  *** 取abc 且 d == x</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; x) ans += <span class="number">10</span> ^ (n - <span class="number">1</span> - i) <span class="comment">//第二种2.2  *** 取abc 且 d &gt;= x</span></span><br></pre></td></tr></table></figure><h4 id="ac-code"><a class="markdownIt-Anchor" href="#ac-code"></a> AC Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i ++)&#123;</span><br><span class="line">        ans = ans * <span class="number">10</span> + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power10</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x --) ans *= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> x)</span> <span class="comment">// 计算1 - n 中x出现的次数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums;  <span class="comment">// 存储 n 的每一位 nums[0]表示最高位</span></span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        nums.<span class="built_in">push_back</span>(n%<span class="number">10</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> + !x; i &lt; n; i ++)&#123; <span class="comment">//！x表示x = 0的时候不考虑第0位就是最高位，因为最高位为0的情况不合法</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> )&#123;</span><br><span class="line">           ans += <span class="built_in">get</span>(nums, <span class="number">0</span> , i - <span class="number">1</span>) * <span class="built_in">power10</span>(n - i - <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">if</span>(!x) ans -= <span class="built_in">power10</span>(n - i - <span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[i] == x) ans += <span class="built_in">get</span>(nums,i + <span class="number">1</span>,n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; x) ans += <span class="built_in">power10</span>(n - i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;a&gt;&gt;b,a || b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)</span><br><span class="line">            cout &lt;&lt; <span class="built_in">count</span>(b,i)  - <span class="built_in">count</span>(a<span class="number">-1</span>,i) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意点"><a class="markdownIt-Anchor" href="#注意点"></a> 注意点</h4><ol><li>get函数中高位向低位遍历，不要弄反了</li><li>x = 0的时候减去000x的情况</li></ol><h4 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> 知识点</h4><p>vector 逆转 <code>reverse(v.begin(),v.end()</code></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间合并</title>
      <link href="/2023/01/12/3-suan-fa/dong-tai-gui-hua/qu-jian-he-bing/"/>
      <url>/2023/01/12/3-suan-fa/dong-tai-gui-hua/qu-jian-he-bing/</url>
      
        <content type="html"><![CDATA[<h4 id="题目-石子合并"><a class="markdownIt-Anchor" href="#题目-石子合并"></a> 题目: <a href="https://www.acwing.com/problem/content/284/">石子合并</a></h4><h4 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h4><p><img src="https://img2023.cnblogs.com/blog/2851436/202301/2851436-20230112195423440-778638186.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202301/2851436-20230112195423440-778638186.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><h4 id="状态转移式推导"><a class="markdownIt-Anchor" href="#状态转移式推导"></a> 状态转移式推导</h4><p><img src="https://img2023.cnblogs.com/blog/2851436/202301/2851436-20230112200115692-751016457.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202301/2851436-20230112200115692-751016457.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><p>f[i][j]:表示合并第i堆到第j堆最小代价时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历区间的时候为了保证计算f[i][j]时所用到的区间都被计算过，采用区间长度遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i ++)&#123;</span><br><span class="line">            <span class="type">int</span> l = i, r = i + len - <span class="number">1</span>;</span><br><span class="line">            f[l][r] = <span class="number">2e8</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = l; k &lt; r; k ++)&#123;</span><br><span class="line">                f[l][r] = <span class="built_in">min</span>(f[l][r],f[l][k]+f[k+<span class="number">1</span>][r]+s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 建站</title>
      <link href="/2023/01/11/4-ri-chang-sui-bi/hexo-jian-zhan/"/>
      <url>/2023/01/11/4-ri-chang-sui-bi/hexo-jian-zhan/</url>
      
        <content type="html"><![CDATA[<p>基本教程  <a href="https://yuang01.github.io/post/hexo-theme-bamboo-new/">https://yuang01.github.io/post/hexo-theme-bamboo-new/</a></p><p>发布文章流程</p><ol><li><code>hexo new &quot;文件名&quot;</code></li><li><code>编写文件</code></li><li><code>hexo clean</code></li><li><code>hexo d</code></li></ol><p>设置评论 <a href="https://utteranc.es/">https://utteranc.es/</a> 授权一下，写对地址</p><p>解决防盗链 图片不显示 <a href="https://www.jianshu.com/p/5b58ecce6443">https://www.jianshu.com/p/5b58ecce6443</a></p><p>解决；Latex 公式问题  <a href="https://zhuanlan.zhihu.com/p/387949353">https://zhuanlan.zhihu.com/p/387949353</a></p><p>我的笔记框架<img src="https://img2023.cnblogs.com/blog/2851436/202301/2851436-20230112191547091-736802604.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202301/2851436-20230112191547091-736802604.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p>]]></content>
      
      
      <categories>
          
          <category> 日常随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django 概述</title>
      <link href="/2023/01/11/1-kai-fa/django/gai-shu/"/>
      <url>/2023/01/11/1-kai-fa/django/gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="新建第一个hello-world"><a class="markdownIt-Anchor" href="#新建第一个hello-world"></a> 新建第一个hello world</h2><ol><li><p>安装Django： <code>python -m pip install Django</code><br /><a href="https://docs.djangoproject.com/zh-hans/4.1/topics/install/#installing-official-release">https://docs.djangoproject.com/zh-hans/4.1/topics/install/#installing-official-release</a></p></li><li><p>创建项目 <code>django-admin startproject mysite</code></p></li><li><p>创建hello world 应用 <code>python manage.py startapp helloworld</code></p></li><li><p>应用链接项目：在mysite的url中链接到helloworld应用的界面---mysite/urls.py---</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;helloworld/&#x27;</span>, include(<span class="string">&#x27;helloworld.urls&#x27;</span>)),</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>运行项目 <code>python manage.py runserver 127.0.0.1:7000</code></p></li></ol><h2 id="常见的初始化配置"><a class="markdownIt-Anchor" href="#常见的初始化配置"></a> 常见的初始化配置</h2><ul><li><p>数据库安装mysql、新建数据库、配置账户密码----mysite/setting.py---</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">  <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;poll&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;654321&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;PORT&#x27;</span>: <span class="string">&#x27;3306&#x27;</span>,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>时区</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TIME_ZONE = <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">USE_TZ = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="路由"><a class="markdownIt-Anchor" href="#路由"></a> 路由</h2><p>django 的 url 中的 path 函数提供路由功能，将用户的每个 url 映射到views中的某个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>url 中带参数：<code>path('&lt;int:question_id&gt;/vote/', views.vote, name='vote')</code></p><h2 id="数据传输"><a class="markdownIt-Anchor" href="#数据传输"></a> 数据传输</h2><h3 id="后端和数据库的数据传输"><a class="markdownIt-Anchor" href="#后端和数据库的数据传输"></a> 后端和数据库的数据传输</h3><ol><li>在model中定义模型<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Question</span>(models.Model):</span><br><span class="line"> question_text = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line"> pub_date = models.DateTimeField(<span class="string">&#x27;data published&#x27;</span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">     <span class="keyword">return</span> self.question_text</span><br></pre></td></tr></table></figure></li><li>运行 <code>python manage.py makemigrations</code> 为模型的改变生成迁移文件。</li><li>运行 <code>python manage.py migrate</code> 来应用数据库迁移。</li><li>运行 <code>python manage.py createsuperuser</code> 创建超级账户</li></ol><h3 id="前端和后端的数据传输"><a class="markdownIt-Anchor" href="#前端和后端的数据传输"></a> 前端和后端的数据传输</h3><ol><li>get 方式 url 中带参数比如url中带question.id后端就把对应的问题从数据库中找出来</li><li>form 方式 字典的方式带数据后端可以request.POST['choice']来获取字典中choice对应的value</li></ol><h2 id="常见函数"><a class="markdownIt-Anchor" href="#常见函数"></a> 常见函数</h2><h3 id="操作数据api"><a class="markdownIt-Anchor" href="#操作数据api"></a> 操作数据API</h3><p><em><strong>增</strong></em>q = Question(question_text=&quot;What's new?&quot;, pub_date=timezone.now())q.save()</p><p><em><strong>删</strong></em>q = Question.objects.get(pk=1)q.delete()<em><strong>查</strong></em><code>Question.object.all()</code> : 获取一个类的所有对象<code>q=Question.objects.get(pk=1)</code></p><p><em><strong>改</strong></em>q = Question.objects.get(pk=1)q.question_text = &quot;xinzhi&quot;q.save()</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/10/hello-world/"/>
      <url>/2023/01/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/2023/01/06/3-suan-fa/ji-chu-suan-fa/05-shuang-zhi-zhen/"/>
      <url>/2023/01/06/3-suan-fa/ji-chu-suan-fa/05-shuang-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<h3 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h3><h4 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h4><ol><li>一般适用于什么情况？</li></ol><h4 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h4><h5 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>; i &lt; n; i ++)&#123; <span class="comment">// 看做快指针，尽管往前面跑</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; n &amp;&amp; <span class="built_in">check</span>(j,i)) j ++;  <span class="comment">// j 看做慢指针， 有需要的情况下跟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题的逻辑</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散化</title>
      <link href="/2023/01/06/3-suan-fa/ji-chu-suan-fa/06-chi-san-hua/"/>
      <url>/2023/01/06/3-suan-fa/ji-chu-suan-fa/06-chi-san-hua/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和 差分</title>
      <link href="/2023/01/05/3-suan-fa/ji-chu-suan-fa/04-qian-zhui-he-he-chai-fen/"/>
      <url>/2023/01/05/3-suan-fa/ji-chu-suan-fa/04-qian-zhui-he-he-chai-fen/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度</title>
      <link href="/2023/01/04/3-suan-fa/ji-chu-suan-fa/03-gao-jing-du/"/>
      <url>/2023/01/04/3-suan-fa/ji-chu-suan-fa/03-gao-jing-du/</url>
      
        <content type="html"><![CDATA[<h3 id="高精度"><a class="markdownIt-Anchor" href="#高精度"></a> 高精度</h3><h4 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h4><p>超长数字的加减乘除 ( len(A),len(B) &gt; 1e6 )</p><h4 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h4><ol><li>大数相加 C = A + B</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123; <span class="comment">// 使用引用是为了加快速度，原数列A,B需要是逆序过得</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">// 表示向下一位的进位， 取 0 | 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || B.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(t); <span class="comment">// 向最高位进位</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>大数相减 C = A - B</li></ol><pre class="highlight"><code class="c++">  <span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, vector&lt;<span class="type">int</span>&gt; B)</span></span>&#123;      &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分</title>
      <link href="/2023/01/02/3-suan-fa/ji-chu-suan-fa/02-er-fen/"/>
      <url>/2023/01/02/3-suan-fa/ji-chu-suan-fa/02-er-fen/</url>
      
        <content type="html"><![CDATA[<h3 id="二分"><a class="markdownIt-Anchor" href="#二分"></a> 二分</h3><h4 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> <a href="https://www.acwing.com/problem/content/791/">问题</a></h4><p>适用于一个序列，有一个check函数，能够使得序列左边都返回false，右边都返回true，然后我们找的就是这个分界点的时候</p><h4 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h4><p>两种情况一种是求 左半段最后一个元素，也就是说求上界，比如求 小于等于 x 的最后一个元素这时候 <code>mid = l + r + 1 &gt;&gt; 1;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid , <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[mid] &lt;= x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid,x)) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>另一种情况是求 右半段的第一个元素，也就是求下界，比如求 大于等于 x 的第一个元素这时候 <code>mid = l + r + 1 &gt;&gt; 1;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid , <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[mid] &gt;= x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid,x)) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h4><p>给定一个序列 q , 求大于等于 x 的第一个值 右半段的第一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid , <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[mid] &gt;= x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, mid;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">    mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid, x)) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(q[l] == x) ...</span><br></pre></td></tr></table></figure><p>给定一个序列 q , 求小于等于 x 的最后一个值 左半段的最后一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid , <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[mid] &lt;= x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, mid;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">    mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid, x)) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(q[l] == x) ...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2023/01/01/3-suan-fa/ji-chu-suan-fa/01-pai-xu/"/>
      <url>/2023/01/01/3-suan-fa/ji-chu-suan-fa/01-pai-xu/</url>
      
        <content type="html"><![CDATA[<h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3><h4 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> <a href="https://www.acwing.com/problem/content/787/">问题</a></h4><p>将序列 q 的 l ~ r 区间排序void quick_sort(int q[], int l, int r)</p><h4 id="基本思想-分治"><a class="markdownIt-Anchor" href="#基本思想-分治"></a> 基本思想 —— 分治</h4><ol><li>找一个参考值 x</li><li>通过双指针算法交换使得  左半边全部是 &lt;= x , 右半边全部是 &gt;= x<ol><li>移动左指针 i ，找到大于 x 的数</li><li>移动右指针 j ，找到小于 x 的数</li><li>交换逆序对</li></ol></li><li>递归处理 左半边 右半边</li></ol><h4 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l] + q[r] &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q[++ i] &lt; x);</span><br><span class="line">        <span class="keyword">while</span>(q[-- j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>( q, l, j), <span class="built_in">quick_sort</span>( q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点</strong>： 分界点的选择可以是[ l , j ]、 [ j + 1 , r ] 或者 [ l, i - 1 ]、[ i , r ],swap 的时候不要忘记判断 i &lt; j</p><h3 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h3><p>与快排的先排完上层，再排下层不同，归并排序是先排完下层再排上层</p><h4 id="问题-2"><a class="markdownIt-Anchor" href="#问题-2"></a> <a href="https://www.acwing.com/problem/content/789/">问题</a></h4><p>将序列 q 的 l ~ r 区间排序void merge_sort(int q[], int l, int r)</p><h4 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h4><ol><li>先排完左半边[ l , mid ]、再排完右半边[ mid + 1, r ]</li><li>将左右两个有序序列进行合并<ol><li>i , j 两个指针分别指向两个有序子序列的头，哪个小就输出哪个，并指向后一个，直到有一个序列指针到达末尾</li><li>将未全部输出的序列全部输出</li></ol></li><li>处理左半边 和 右半边 同样使用递归的方式</li></ol><h4 id="模板-2"><a class="markdownIt-Anchor" href="#模板-2"></a> 模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp[N]; <span class="comment">// 很大，最好开在外面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>; <span class="comment">// 递归的出口</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid), <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j]) tmp[k ++] = q[i ++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++] = q[j ++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k ++] = q[i ++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k ++] = q[j ++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程登录和 vim</title>
      <link href="/2022/12/04/1-kai-fa/linux/yuan-cheng-deng-lu-he-vim/"/>
      <url>/2022/12/04/1-kai-fa/linux/yuan-cheng-deng-lu-he-vim/</url>
      
        <content type="html"><![CDATA[<h3 id="主机和虚拟机ping不通的原因"><a class="markdownIt-Anchor" href="#主机和虚拟机ping不通的原因"></a> 主机和虚拟机ping不通的原因</h3><ol><li>主机需要将自己网卡共享给VMware net8</li><li>主机VMware net8虚拟网卡设计的网段需要和虚拟机中vmnet8 的网段设置为一样的如果不一致，会出现主机ping不通虚拟机，反之可以，同时虚拟机也能上网</li></ol><h3 id="远程登录传输"><a class="markdownIt-Anchor" href="#远程登录传输"></a> 远程登录传输</h3><p>虚拟机ip  192.168.126.128   Vmwarenet8 196.168.126.0</p><p>连接工具： XShell 和 XFTP连接的时候主机一定要选择虚拟机（就是linux所在主机）<strong>的ip</strong>小问题：如果使用XFTP出现乱码的话，将语言改为UTF-8</p><p>连接成功后就可以远程通过用户名和密码 远程登录到linux系统</p><h3 id="vim使用以及快捷键"><a class="markdownIt-Anchor" href="#vim使用以及快捷键"></a> vim使用以及快捷键</h3><p>vim的三种模式</p><ol><li>正常模式 默认进去的模式，可以光标移动</li><li>编辑模式 正常+ i\a 可以进行编辑</li><li>命令模式 正常+：可以输入命令   :wq 保存并退出 :q! 强制退出</li></ol><h4 id="各种模式的切换"><a class="markdownIt-Anchor" href="#各种模式的切换"></a> 各种模式的切换</h4><p><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221002232546072-1965942321.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221002232546072-1965942321.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><h4 id="常用快捷键"><a class="markdownIt-Anchor" href="#常用快捷键"></a> 常用快捷键</h4><ul><li>yy 复制当前行  5yy 复制之后的5行    p 粘贴</li><li>dd 删除当前行  6dd删除当前行后的6行</li><li></li><li>:set nu 显示行号  :set nonu 取消行号</li><li></li><li>正常模式下：输入u撤销操作，就是输错了，先ESC，然后再u</li><li>正常模式下：跳转到第一行 gg  跳转到最后一行G</li><li>正常模式下： /hello 回车 开始搜索文件中的hello  使用n选择next个匹配项</li><li>正常模式下：输入行号n，然后shift+g  go到第n行</li><li>任何模式切换为正常模式 按ESC键</li></ul><p><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221002234541152-1804272133.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221002234541152-1804272133.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 常用命令</title>
      <link href="/2022/12/01/1-kai-fa/linux/chang-yong-ming-ling/"/>
      <url>/2022/12/01/1-kai-fa/linux/chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h2><h3 id="文件管理"><a class="markdownIt-Anchor" href="#文件管理"></a> 文件管理</h3><ol><li><p>删除 rm option 文件/文件名option  -r:删除目录及其子文件   -f: 即使原档案属性设为唯读，亦直接删除，无需逐一确认<code>sudo rm a.txt</code>  //删除文件<code>sudo rm -r test</code> //删除test文件夹</p></li><li><p>创建创建文件 <code>touch a.txt</code>  创建a.txt 文件创建文件夹  <code>mkdir a</code>   创建文件夹a</p></li><li><p>解压<code>tar -zxvf filename</code></p></li><li><p>用户操作添加用户   <code>useradd 用户名</code>删除用户   <code>userdel -r 用户名</code></p></li><li><p>cd命令cd a  是进入当前目录下的a文件夹中cd /a 是进入根目录下的a中  '/'代表根目录</p></li><li><p>开关机指令shutdown -</p></li><li><p>关于相对路径的引用a-a1-a2b-b1-b2</p><ol><li>当前目录中的文件夹a1  \a1</li><li>上一级目录 ..\</li><li>同级目录b  ..\b</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 概述和安装</title>
      <link href="/2022/11/28/1-kai-fa/linux/gai-shu-he-huan-jing-an-zhuang/"/>
      <url>/2022/11/28/1-kai-fa/linux/gai-shu-he-huan-jing-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><h3 id="学习路线"><a class="markdownIt-Anchor" href="#学习路线"></a> 学习路线</h3><p><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221002113558157-2074263708.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221002113558157-2074263708.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><h3 id="环境安装"><a class="markdownIt-Anchor" href="#环境安装"></a> 环境安装</h3><p>linux Cent OS 7.6  [该版本已经不再维护]地址：<a href="https://vault.centos.org/7.6.1810/isos/x86_64/">https://vault.centos.org/7.6.1810/isos/x86_64/</a></p><h3 id="网络连接的三种方式"><a class="markdownIt-Anchor" href="#网络连接的三种方式"></a> 网络连接的三种方式</h3><p>桥接模式：虚拟机有独立的ip，占用当前网段的ipNAT地址转换模式：虚拟机通过主机代理向别的主机发送请求，不占用ip</p><p><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221002153240354-538715935.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221002153240354-538715935.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><h3 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h3><p><strong>linux一切皆文件</strong>根目录  /bin  存放常用命令的具体实现，就是像 cd  tar等等sbin superbin的意思，就是存放管理员才能使用的命令的具体实现opt  一般存放安装包home  存放每个用户的数据（用户名、密码等等），一个用户对应一个子文件夹，加入一个用户tom，那usr下就有一个子文件夹tom若使用命令 useradd jack 那就加了一个jack文件夹ect  存放一些配置信息，用户配置 or 软件配置 ( mysql 账号密码？)root 存放管理员用户的数据信息boot 存放系统引导信息usr  存放用户的应用程序和文件usr/local 一般为软件安装的目录mnt 挂载的文件系统 比如共享文件夹 D:/mysharevar 存放不断扩大的东西，比如日志tmp 存放临时文件dev 存放设备信息，以文件的形式存储</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机视觉》 笔记</title>
      <link href="/2022/10/25/2-ji-suan-ji-shi-jue/ji-suan-ji-shi-jue-bi-ji/"/>
      <url>/2022/10/25/2-ji-suan-ji-shi-jue/ji-suan-ji-shi-jue-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="先验-后验-和-似然函数的关系"><a class="markdownIt-Anchor" href="#先验-后验-和-似然函数的关系"></a> <a href="https://zhuanlan.zhihu.com/p/157677467">先验 后验 和 似然函数的关系</a></h3><h3 id="常见的概率分布模型"><a class="markdownIt-Anchor" href="#常见的概率分布模型"></a> 常见的概率分布模型</h3><p>概率分布就是一个公式，给定X，就能计算出在这一点X的概率（或者连续随机变量的话就是这一点的概率密度）</p><p><em><strong>伯努利分布</strong></em>描述一个像素的灰度值大于或者小于128的概率</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mrow><mo fence="true">(</mo><mi>x</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><mn>0</mn><mo fence="true">)</mo></mrow><mtext> </mtext><mo>=</mo><mtext> </mtext><mn>1</mn><mtext> </mtext><mo>−</mo><mtext> </mtext><mi>λ</mi><mtext>   </mtext><mrow><mo fence="true">(</mo><mn>0</mn><mo>:</mo><mtext>灰度值小于</mtext><mn>128</mn><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">P\left( x\ =\ 0 \right) \ =\ 1\ -\ \lambda \ \ \ \left( 0:\text{灰度值小于}128 \right) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord cjk_fallback">灰度值小于</span></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mrow><mo fence="true">(</mo><mi>x</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><mn>1</mn><mo fence="true">)</mo></mrow><mtext>  </mtext><mo>=</mo><mtext> </mtext><mi>λ</mi><mtext> </mtext><mrow><mo fence="true">(</mo><mn>1</mn><mo>:</mo><mtext>灰度值大于</mtext><mn>128</mn><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">P\left( x\ =\ 1 \right) \ \ =\ \lambda \ \left( 1:\text{灰度值大于}128 \right) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord cjk_fallback">灰度值大于</span></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>或者统一为</mtext></mrow><annotation encoding="application/x-tex">\text{或者统一为}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">或者统一为</span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow><mtext> </mtext><mo>=</mo><mtext> </mtext><msup><mi>λ</mi><mi>x</mi></msup><mtext> </mtext><mo>∗</mo><mtext> </mtext><msup><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><mi>λ</mi><mo fence="true">)</mo></mrow><mrow><mn>1</mn><mo>−</mo><mi>x</mi></mrow></msup></mrow><annotation encoding="application/x-tex">P\left( x \right) \ =\ \lambda ^x\ *\ \left( 1-\lambda \right) ^{1-x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.204008em;vertical-align:-0.25em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">λ</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><em><strong>贝塔分布</strong></em>一个连续的分布，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>由单变量</mtext><mi>λ</mi><mtext>定义的连续分布，</mtext><mi>λ</mi><mo>=</mo><mrow><mo fence="true">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo fence="true">]</mo></mrow><mo separator="true">,</mo><mtext>适合表示伯努利分布的参数</mtext><mi>λ</mi><mtext>的不确定性</mtext></mrow><annotation encoding="application/x-tex">\text{由单变量}\lambda \text{定义的连续分布，}\lambda =\left[ 0,1 \right] ,\text{适合表示伯努利分布的参数}\lambda \text{的不确定性}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">由单变量</span></span><span class="mord mathnormal">λ</span><span class="mord text"><span class="mord cjk_fallback">定义的连续分布，</span></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord cjk_fallback">适合表示伯努利分布的参数</span></span><span class="mord mathnormal">λ</span><span class="mord text"><span class="mord cjk_fallback">的不确定性</span></span></span></span></span></p><p><em><strong>分类分布</strong></em>一个离散的分布，用来表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>个可能的结果的概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\lambda _k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><em><strong>狄利克雷分布</strong></em>一个连续的分布，用于表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>个连续值(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mrow><mn>1...</mn><mi>K</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\lambda _{1...K}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)的取值情况，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></msubsup><msub><mi>λ</mi><mi>k</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_{k=1}^K{\lambda _k}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2809409999999999em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，适合表示分类分布参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\lambda _k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的分布</p><h3 id="拟合概率模型的方法极大似然-最大后验-贝叶斯方法"><a class="markdownIt-Anchor" href="#拟合概率模型的方法极大似然-最大后验-贝叶斯方法"></a> 拟合概率模型的方法——极大似然、最大后验、贝叶斯方法</h3><p><em><strong>基本概念</strong></em><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mtext>先验</mtext><mspace linebreak="newline"></mspace><mtext> </mtext></mrow><mi>P</mi><mrow><mo fence="true">(</mo><mi>θ</mi><mo fence="true">)</mo></mrow><mo>:</mo><mtext>不考虑样本，这个分布的参数应该满足什么样的分布</mtext></mrow><annotation encoding="application/x-tex">\text{先验\\ }P\left( \theta \right) :\text{不考虑样本，这个分布的参数应该满足什么样的分布}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord cjk_fallback">先验</span><span class="mspace newline"></span><span class="mord"> </span></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">不考虑样本，这个分布的参数应该满足什么样的分布</span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mtext>后验</mtext><mspace linebreak="newline"></mspace><mtext> </mtext></mrow><mi>P</mi><mrow><mo fence="true">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo fence="true">)</mo></mrow><mo>:</mo><mtext>在已知样本</mtext><mi>x</mi><mtext>的结果的前提下，分布的参数是</mtext><mi>θ</mi><mtext>的概率是多少</mtext></mrow><annotation encoding="application/x-tex">\text{后验\\ }P\left( \theta |x \right) :\text{在已知样本}x\text{的结果的前提下，分布的参数是}\theta \text{的概率是多少}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord cjk_fallback">后验</span><span class="mspace newline"></span><span class="mord"> </span></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">在已知样本</span></span><span class="mord mathnormal">x</span><span class="mord text"><span class="mord cjk_fallback">的结果的前提下，分布的参数是</span></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord text"><span class="mord cjk_fallback">的概率是多少</span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mtext>似然</mtext><mspace linebreak="newline"></mspace><mtext> </mtext></mrow><mi>P</mi><mrow><mo fence="true">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo fence="true">)</mo></mrow><mo>:</mo><mtext> 好像就是实际的分布，就是说实际的分布的参数假如说是</mtext><mi>θ</mi><mtext> 的话，那么</mtext><mi>x</mi><mtext>的概率是啥</mtext></mrow><annotation encoding="application/x-tex">\text{似然\\ }P\left( x|\theta \right) :\ \text{好像就是实际的分布，就是说实际的分布的参数假如说是}\theta \ \text{的话，那么}x\text{的概率是啥}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord cjk_fallback">似然</span><span class="mspace newline"></span><span class="mord"> </span></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">好像就是实际的分布，就是说实际的分布的参数假如说是</span></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace"> </span><span class="mord text"><span class="mord cjk_fallback">的话，那么</span></span><span class="mord mathnormal">x</span><span class="mord text"><span class="mord cjk_fallback">的概率是啥</span></span></span></span></span></p><h4 id="最大似然拟合概率模型-ml"><a class="markdownIt-Anchor" href="#最大似然拟合概率模型-ml"></a> 最大似然拟合概率模型 ML</h4><p>顾名思义就是说最大化 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mrow><mo fence="true">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>P</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mrow><mn>1..</mn><mi>n</mi></mrow></msub><mi mathvariant="normal">∣</mi><mi>θ</mi><mo fence="true">)</mo></mrow><mo>=</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mrow><mi>P</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>θ</mi><mo fence="true">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">P\left( x|\theta \right) =P\left( x_{1..n}|\theta \right) =\prod_{i=1}^n{P\left( x_i|\theta \right)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span>，求解其中的未知量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mo><mi mathvariant="normal">arg max</mi><mo>⁡</mo></mo><mi>θ</mi></munder><mi>P</mi><mrow><mo fence="true">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\argmax_{\theta}P\left( x|\theta \right) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.696548em;vertical-align:-0.946548em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43055999999999994em;"><span style="top:-2.153452em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.946548em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>=</mo><munder><mo><mi mathvariant="normal">arg max</mi><mo>⁡</mo></mo><mi>θ</mi></munder><mi>P</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mrow><mn>1..</mn><mi>n</mi></mrow></msub><mi mathvariant="normal">∣</mi><mi>θ</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">=\argmax_{\theta}P\left( x_{1..n}|\theta \right) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.696548em;vertical-align:-0.946548em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43055999999999994em;"><span style="top:-2.153452em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.946548em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>=</mo><munder><mo><mi mathvariant="normal">arg max</mi><mo>⁡</mo></mo><mi>θ</mi></munder><munderover><mo>∏</mo><mi>i</mi><mi>n</mi></munderover><mrow><mi>P</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>θ</mi><mo fence="true">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">=\argmax_{\theta}\prod_i^n{P\left( x_i|\theta \right)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43055999999999994em;"><span style="top:-2.153452em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.946548em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>=</mo><munder><mo><mi mathvariant="normal">arg max</mi><mo>⁡</mo></mo><mi>θ</mi></munder><mtext> </mtext><mo>∑</mo><mrow><mi>log</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mi>P</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>θ</mi><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">=\argmax_{\theta}\ \sum{\log \left( P\left( x_i|\theta \right) \right)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.996548em;vertical-align:-0.946548em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43055999999999994em;"><span style="top:-2.153452em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.946548em;"><span></span></span></span></span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></span></p><h4 id="最大后验拟合概率模型-map"><a class="markdownIt-Anchor" href="#最大后验拟合概率模型-map"></a> 最大后验拟合概率模型 MAP</h4><p>顾名思义就是最大化后验</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mo><mi mathvariant="normal">arg max</mi><mo>⁡</mo></mo><mi>θ</mi></munder><mi>P</mi><mrow><mo fence="true">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\argmax_{\theta}P\left( \theta |x \right) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.696548em;vertical-align:-0.946548em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43055999999999994em;"><span style="top:-2.153452em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.946548em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>=</mo><munder><mo><mi mathvariant="normal">arg max</mi><mo>⁡</mo></mo><mi>θ</mi></munder><mfrac><mrow><mi>P</mi><mrow><mo fence="true">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo fence="true">)</mo></mrow><mtext> </mtext><mo>×</mo><mtext> </mtext><mi>P</mi><mrow><mo fence="true">(</mo><mi>θ</mi><mo fence="true">)</mo></mrow></mrow><mrow><mi>P</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">=\argmax_{\theta}\frac{P\left( x|\theta \right) \ \times \ P\left( \theta \right)}{P\left( x \right)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.373548em;vertical-align:-0.946548em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43055999999999994em;"><span style="top:-2.153452em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.946548em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>=</mo><munder><mo><mi mathvariant="normal">arg max</mi><mo>⁡</mo></mo><mi>θ</mi></munder><mi>P</mi><mrow><mo fence="true">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo fence="true">)</mo></mrow><mtext> </mtext><mo>∗</mo><mtext> </mtext><mi>P</mi><mrow><mo fence="true">(</mo><mi>θ</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">=\argmax_{\theta}P\left( x|\theta \right) \ *\ P\left( \theta \right) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.696548em;vertical-align:-0.946548em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43055999999999994em;"><span style="top:-2.153452em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.946548em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p><p>他有个好处就是可以利用到先验的知识，不像极大似然估计只知道用样本的数据进行拟合，这个还考虑到了先验的概率，但是先验的参数怎么确定呢，有利也有弊，后验方式是先验和极大似然方式的加权平均</p><h4 id="贝叶斯方式"><a class="markdownIt-Anchor" href="#贝叶斯方式"></a> 贝叶斯方式</h4><p>其实我们的最终目的不是求参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>,而是给定一个新数据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">x^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>要计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msup><mi>x</mi><mo>∗</mo></msup><mi mathvariant="normal">∣</mi><msub><mi>X</mi><mrow><mn>1..</mn><mi>I</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x^*|X _{1..I})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的概率 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mrow><mn>1..</mn><mi>I</mi></mrow></msub></mrow><annotation encoding="application/x-tex">X _{1..I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示已有的抽样的数据) ，之前都是找出一个概率最大的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>,其实这个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>也满足一个分布，我们直接对他进行每个概率都给他乘上，然后加权一下就好了</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mrow><mo fence="true">(</mo><msup><mi>x</mi><mo>∗</mo></msup><mi mathvariant="normal">∣</mi><msub><mi>X</mi><mrow><mn>1..</mn><mi>I</mi></mrow></msub><mo fence="true">)</mo></mrow><mtext> </mtext><mo>=</mo><mtext> </mtext><mo>∫</mo><mrow><mi>P</mi><mrow><mo fence="true">(</mo><msup><mi>x</mi><mo>∗</mo></msup><mi mathvariant="normal">∣</mi><mi>θ</mi><mo fence="true">)</mo></mrow><mtext> </mtext><mo>∗</mo><mtext> </mtext><mi>P</mi><mrow><mo fence="true">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo fence="true">)</mo></mrow><mtext> </mtext><mi>d</mi><mi>θ</mi></mrow></mrow><annotation encoding="application/x-tex">P\left( x^*|X _{1..I} \right) \ =\ \int{P\left( x^*|\theta \right) \ *\ P\left( \theta |x \right) \ d\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.22225em;vertical-align:-0.86225em;"></span><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span></span></span></p><p>贝叶斯方式去除了计算参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>的误差，更加合理</p><p><em><strong>小tip</strong></em>：<strong>正定矩阵</strong>： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>正定矩阵</mtext><mi>Σ</mi><mtext>满足： </mtext><msup><mi>Z</mi><mi>T</mi></msup><mo>∗</mo><mtext> </mtext><mi mathvariant="normal">Σ</mi><mtext> </mtext><mo>∗</mo><mtext> </mtext><mi>Z</mi><mtext> 恒为正</mtext></mrow><annotation encoding="application/x-tex">\text{正定矩阵}\varSigma \text{满足：\ }Z^T*\ \Sigma \ *\ Z\ \text{恒为正}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">正定矩阵</span></span><span class="mord"><span class="mord mathit">Σ</span></span><span class="mord text"><span class="mord cjk_fallback">满足：</span><span class="mord"> </span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace"> </span><span class="mord text"><span class="mord cjk_fallback">恒为正</span></span></span></span></span>方差： 用来衡量单个随机变量的离散程度协方差： 用来衡量两个随机变量的相似程度协方差矩阵: 用来衡量了 一个具有多个随机变量的 分布 的离散程度</p><h3 id="生成模型和判别模型"><a class="markdownIt-Anchor" href="#生成模型和判别模型"></a> 生成模型和判别模型</h3><p><em><strong>判别模型</strong></em>： 比较简单直接计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>w</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo><mtext>这里的</mtext><mi>w</mi><mtext>叫做全局状态</mtext><mo stretchy="false">(</mo><mtext>我理解就是</mtext><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(w|x) 这里的w叫做全局状态(我理解就是y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">的</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord cjk_fallback">叫</span><span class="mord cjk_fallback">做</span><span class="mord cjk_fallback">全</span><span class="mord cjk_fallback">局</span><span class="mord cjk_fallback">状</span><span class="mord cjk_fallback">态</span><span class="mopen">(</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">解</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">是</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 大概就是先估计一下w的分布，比如说在例子通过轮胎像素的个数，来估计车身的大小的样例中，w估计就是一元正态分布<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>w</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo separator="true">,</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>N</mi><mi>o</mi><mi>r</mi><msub><mi>m</mi><mi>w</mi></msub><mo stretchy="false">[</mo><mi>a</mi><mo>+</mo><mi>b</mi><mi>x</mi><mo separator="true">,</mo><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false">]</mo><mtext>这里的</mtext><mi>θ</mi><mtext>就是一些需要确定得超参数，包括</mtext><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>σ</mi><mo separator="true">,</mo><mtext>所以只要求出</mtext><mi>θ</mi><mtext>的估计值就可以进行推理</mtext><mo stretchy="false">(</mo><mtext>我立即的是预测</mtext><mo stretchy="false">)</mo><mtext>了。</mtext><mspace linebreak="newline"></mspace><mtext>确定超参数有好多算法，比如可以用</mtext><mi>M</mi><mi>A</mi><mi>P</mi><mtext>算法求</mtext><msub><mo><mi mathvariant="normal">arg max</mi><mo>⁡</mo></mo><mi>θ</mi></msub><mi>P</mi><mrow><mo fence="true">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo fence="true">)</mo></mrow><mtext> </mtext><mo>∗</mo><mtext> </mtext><mi>P</mi><mrow><mo fence="true">(</mo><mi>θ</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">P(w|x,\theta) = Norm_w[a + bx,\sigma^2] 这里的\theta就是一些需要确定得超参数，包括a,b,\sigma,所以只要求出\theta的估计值就可以进行推理(我立即的是预测)了。\\确定超参数有好多算法，比如可以用MAP算法求\argmax_{\theta}P\left( x|\theta \right) \ *\ P\left( \theta \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">的</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">些</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">确</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">超</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">括</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">只</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">求</span><span class="mord cjk_fallback">出</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">估</span><span class="mord cjk_fallback">计</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">推</span><span class="mord cjk_fallback">理</span><span class="mopen">(</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">立</span><span class="mord cjk_fallback">即</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">预</span><span class="mord cjk_fallback">测</span><span class="mclose">)</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">。</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">确</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">超</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">好</span><span class="mord cjk_fallback">多</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">用</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">求</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop"><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.24196799999999993em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></p><p><em><strong>生成模型</strong></em>：假如说是一个分类问题，就拟合分类为0的数据的模型，然后拟合分类为1的数据的模型，然后对于一个给定的数据，带入到两个模型，看看哪个概率打， 就属于哪个【这是w为离散的情况，好理解些】【w连续的情况】 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>要计算的是</mtext><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mo separator="true">,</mo><mi>θ</mi><mo stretchy="false">)</mo><mtext>就是说在每一个全局状态</mtext><mi>w</mi><mtext>下，存在</mtext><mi>x</mi><mtext>这种数据的概率</mtext><mo separator="true">,</mo><mtext>通过样本</mtext><mrow><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><mtext>可以计算出参数</mtext><mi>θ</mi><mtext>从而求得</mtext><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi mathvariant="normal">/</mi><mtext>这种情况需要先预估</mtext><mi>w</mi><mtext>的分布，然后用现有的</mtext><msub><mi>w</mi><mi>i</mi></msub><mtext>样本去拟合这个分布，得到</mtext><mi>P</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mtext>这样就可以利用贝叶斯公式计算出后验</mtext><mi>P</mi><mo stretchy="false">(</mo><mi>w</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>p</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">要计算的是 P(x|w,\theta) 就是说在每一个全局状态w下，存在x这种数据的概率,通过样本{x_i,w_i} 可以计算出参数\theta从而求得P(x|w)//这种情况需要先预估w的分布，然后用现有的w_i样本去拟合这个分布，得到P(w) 这样就可以利用贝叶斯公式计算出后验P(w|x) = P(x|w) * p(w) / p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">计</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">是</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">说</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">每</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">全</span><span class="mord cjk_fallback">局</span><span class="mord cjk_fallback">状</span><span class="mord cjk_fallback">态</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mord mathnormal">x</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">种</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">概</span><span class="mord cjk_fallback">率</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">本</span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">计</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord cjk_fallback">从</span><span class="mord cjk_fallback">而</span><span class="mord cjk_fallback">求</span><span class="mord cjk_fallback">得</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">/</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">种</span><span class="mord cjk_fallback">情</span><span class="mord cjk_fallback">况</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">先</span><span class="mord cjk_fallback">预</span><span class="mord cjk_fallback">估</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">布</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">然</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">现</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">的</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">本</span><span class="mord cjk_fallback">去</span><span class="mord cjk_fallback">拟</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">布</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">到</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">利</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">贝</span><span class="mord cjk_fallback">叶</span><span class="mord cjk_fallback">斯</span><span class="mord cjk_fallback">公</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">计</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">验</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《计算机视觉》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LSTM</title>
      <link href="/2022/10/20/2-ji-suan-ji-shi-jue/lstm/lstm/"/>
      <url>/2022/10/20/2-ji-suan-ji-shi-jue/lstm/lstm/</url>
      
        <content type="html"><![CDATA[<p>LSTM 又叫长 短时记忆神经网络，问了解决RNN不能处理 <code>从较长的前文中推断下一个单词的问题</code> 而提出的<code>从较长的前文中推断下一个单词的问题</code>比如：&quot;I grew up in France… I speak fluent <em>French</em>.&quot;不能从这句中推出French，因为中间隔了好多词</p><h4 id="遗忘门"><a class="markdownIt-Anchor" href="#遗忘门"></a> 遗忘门：</h4><p><img src="https://img2022.cnblogs.com/blog/2851436/202211/2851436-20221126212224503-712213887.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202211/2851436-20221126212224503-712213887.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><h4 id="输入门"><a class="markdownIt-Anchor" href="#输入门"></a> 输入门：</h4><p><img src="https://img2022.cnblogs.com/blog/2851436/202211/2851436-20221126212311075-209010384.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202211/2851436-20221126212311075-209010384.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><h4 id="想下一个cell的输出"><a class="markdownIt-Anchor" href="#想下一个cell的输出"></a> 想下一个cell的输出：</h4><p><img src="https://img2022.cnblogs.com/blog/2851436/202211/2851436-20221126212423984-1696402345.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202211/2851436-20221126212423984-1696402345.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><h4 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出：</h4><p><img src="https://img2022.cnblogs.com/blog/2851436/202211/2851436-20221126212440327-44970240.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202211/2851436-20221126212440327-44970240.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><p><a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/#fn1">参考链接1</a><a href="https://zhuanlan.zhihu.com/p/84333843">中文版参考链接</a><a href="https://www.bilibili.com/video/BV1J94y1f7u5?p=28&amp;vd_source=a25e4be5f25feef1532666f6ee51cce1">李宏毅RNN教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 李宏毅笔记 </tag>
            
            <tag> LSTM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAN 李宏毅笔记</title>
      <link href="/2022/10/19/2-ji-suan-ji-shi-jue/gan/gan-gai-shu/"/>
      <url>/2022/10/19/2-ji-suan-ji-shi-jue/gan/gan-gai-shu/</url>
      
        <content type="html"><![CDATA[<p>GAN(Generative Adversarial Network) 生成对抗网络</p><h4 id="1-为什么要有这个东西"><a class="markdownIt-Anchor" href="#1-为什么要有这个东西"></a> 1. 为什么要有这个东西？</h4><p>为了解决相同输入x，不同输出y的情形,每一个输出都是对的，唯一可以知道的是他服从某一个分布。</p><p>李宏毅中的例子是根据游戏的前三帧，去预测下一帧，当前三帧游戏人物走到路口的时候，下一帧可能左拐也可能右拐，无法得到一个确切的输出，只能得到一个概率分布。也可以用于扩充样本。</p><h4 id="2-生成对抗网络是什么"><a class="markdownIt-Anchor" href="#2-生成对抗网络是什么"></a> 2. 生成对抗网络是什么？</h4><p>一个生成对抗网络主要包含 生成器 + 判别器</p><ol><li><p><code>生成器(G)</code>的主要作用就是根据一个输入z（满足某个分布的向量）随机生成输出y（满足另一个分布）</p></li><li><p><code>判别器(D)</code>的主要作用是判断G的某一堆输出y_s与最终要生成的数据的相似程度 相似度越高打分越高</p></li><li><p>直观理解：</p><p>3.1 正常的network都是给定一个 x,得到一个 y, 记作<code>&#123;f(x) = y&#125;</code></p><p>3.2 这里为了使得给定一个x得到不同的y，同时再给定一个z1(满足某种简单的分布Z)，这样便成了 <code>f(x,z1) = y</code>。</p><p>3.3 因为z服从一个分布Z，那么y也服从一个分布Y，这样的话对于一个输入x得到的输出就是一个分布，而不是确定的值，等到预测的时候 给定x, 同时从Z分中随机选取一个z1，就能得到一个满足Y分布的结果</p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129161135195-2104431847.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129161135195-2104431847.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p></li></ol><h4 id="4-如何保证分布y就是我们想要的-概率分布呢"><a class="markdownIt-Anchor" href="#4-如何保证分布y就是我们想要的-概率分布呢"></a> 4. 如何保证分布Y就是我们想要的 概率分布呢？</h4><p>使用 判别器D 建立一个分类的network，他的输入是 生成器G 的输出，和我们已知的样本分布，输出是一个值，表示他和所需要生成的样本的差异程度，用这个值来表示 生成器G 表现好不好<img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129165154824-1146175719.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129165154824-1146175719.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><p>真正计算的时候： 从real_data (标签1) 和 generated_data(标签0) 中随机抽取出若干个输入network分类，设定loss使得real_data得分尽可能高，generated_data 的分尽可能低</p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129201624345-504111067.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129201624345-504111067.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><p>同时可以从理论上推导这个 loss Function和 JS Diversion 是有关联的，直观理解也好理解，只有分布相似，差异小才难分，然后那个maxV才不会太大，所有Diversion越小，maxV越小【具体推导见GAN原paper：<a href="https://arxiv.org/abs/1406.2661">https://arxiv.org/abs/1406.2661</a> 】</p><h4 id="5-整体优化目标是什么如何训练"><a class="markdownIt-Anchor" href="#5-整体优化目标是什么如何训练"></a> 5. 整体优化目标是什么，如何训练？</h4><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129205011815-1057653954.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129205011815-1057653954.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><h4 id="6-gan-是很难train的原因是什么"><a class="markdownIt-Anchor" href="#6-gan-是很难train的原因是什么"></a> 6. GAN 是很难train的，原因是什么？</h4><ol><li><p>真实数据和生成的数据的分布存在重合很难 （1.所有图像空间中动漫的分布很小很小，存在交集就更难了 2.即使分布存在交集，我们sample出来的点构成的分布未必存在交集）</p></li><li><p>JS Diversion的特性是只要没有重合那两个分布的距离就是固定的log2</p></li></ol><p>所以可以看出JS divergence 不好，后人改用了W distance（Wasserstein distance）来衡量两个分布之间的距离，它的定义是通过移动一个分</p><p>布P中的样本点使其满足另一个分布Q，所需要移动的最小距离就是W distance</p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129213001543-1442672159.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129213001543-1442672159.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><p><em><strong>6.1 那W distance 如何计算</strong></em></p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129214907059-345839759.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129214907059-345839759.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><p><em><strong>lipschitz 条件</strong></em></p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129215424056-2087370460.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129215424056-2087370460.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><p><em><strong>6.2 如何使得函数D满足上述条件</strong></em></p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129220105514-1144868367.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129220105514-1144868367.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><h4 id="7-生成器-和-判别器-必须水平相当才能训练起来怎么保证双方水平相当呢"><a class="markdownIt-Anchor" href="#7-生成器-和-判别器-必须水平相当才能训练起来怎么保证双方水平相当呢"></a> 7. 生成器 和 判别器 必须水平相当才能训练起来，怎么保证双方水平相当呢？</h4><p>一些tip</p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129223448387-1713605195.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129223448387-1713605195.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><h4 id="8-怎么评估一个gan的好坏评估其生成的图片的质量的好坏"><a class="markdownIt-Anchor" href="#8-怎么评估一个gan的好坏评估其生成的图片的质量的好坏"></a> 8. 怎么评估一个GAN的好坏，评估其生成的图片的质量的好坏</h4><p><strong><strong>评估图像质量</strong></strong></p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129231650951-2123842083.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129231650951-2123842083.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><p><em><strong>评估图像多样性</strong></em></p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129231619137-1629877941.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129231619137-1629877941.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><p>综合质量和多样性的话就是Inception Score</p><p><em><strong>这种评估手段无法检测出的一些问题</strong></em></p><p><img src="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129225216914-758335728.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202211/2851436-20221129225216914-758335728.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><h4 id="9-有条件生成对抗网络"><a class="markdownIt-Anchor" href="#9-有条件生成对抗网络"></a> 9. 有条件生成对抗网络</h4><p><img src="https://img2023.cnblogs.com/blog/2851436/202212/2851436-20221201105722166-1866872542.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202212/2851436-20221201105722166-1866872542.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><p><em><strong>conditional GAN 的应用</strong></em></p><ol><li>文字产生图像--&gt; AI 绘图</li><li>图像长生图像--&gt; Pix2Pix 图像转换 与正常不同的是对于相同的输入可以产生不同的输出</li><li>语音产生图像</li><li>图像产生动图</li><li>...</li></ol><h4 id="10-几种常见的gan"><a class="markdownIt-Anchor" href="#10-几种常见的gan"></a> 10. 几种常见的GAN</h4><ol><li>原生GAN</li><li>DCGAN：G 使用的是反向卷积网络（一维的输入变为二维的输出）</li><li>WGAN ： 改进了损失函数，解决了原本的损失函数难以敏感的反应两个不相交的分布的距离这一问题</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAN </tag>
            
            <tag> 李宏毅笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵乘法中的梯度计算（反向传播常用）</title>
      <link href="/2022/10/07/2-ji-suan-ji-shi-jue/cnn/si-kao-ju-zhen-cheng-fa-de-ti-du-ji-suan-tui-dao-guo-cheng/"/>
      <url>/2022/10/07/2-ji-suan-ji-shi-jue/cnn/si-kao-ju-zhen-cheng-fa-de-ti-du-ji-suan-tui-dao-guo-cheng/</url>
      
        <content type="html"><![CDATA[<p>神经网络中的反向传播中的梯度计算一直是让我和头疼的问题，翻了好多资料，现在记录下自己目前的所得</p><ol start="0"><li>结论</li></ol><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>设 </mtext><mi>y</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><mi>f</mi><mrow><mo fence="true">(</mo><mi>X</mi><mtext> </mtext><mo>∗</mo><mtext> </mtext><mi>W</mi><mo fence="true">)</mo></mrow><mtext> </mtext><mo separator="true">,</mo><mtext> </mtext><mi>C</mi><mo>=</mo><mi>X</mi><mtext> </mtext><mo>∗</mo><mtext> </mtext><mi>W</mi><mo separator="true">,</mo><mtext>则有:</mtext></mrow><annotation encoding="application/x-tex">\text{设\ }y\ =\ f\left( X\ *\ W \right) \ ,\ C=X\ *\ W,\text{则有:}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord cjk_fallback">设</span><span class="mord"> </span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord cjk_fallback">则有</span><span class="mord">:</span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>W</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow></mfrac><mo>=</mo><msup><mi>X</mi><mi>T</mi></msup><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>C</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial y}{\partial W_{i,j}}=X^T\frac{\partial y}{\partial C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.3435479999999997em;vertical-align:-0.972108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.972108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.0574399999999997em;vertical-align:-0.686em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>X</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>C</mi></mrow></mfrac><msup><mi>W</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\frac{\partial y}{\partial X_{i,j}}=\frac{\partial y}{\partial C}W^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.3435479999999997em;vertical-align:-0.972108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.972108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.0574399999999997em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></p><ol><li><a href="https://www.cnblogs.com/milaohu/p/7337330.html?utm_source=itdadao&amp;utm_medium=referral">转载自大佬笔记</a></li></ol><p><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221021155540030-886714468.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221021155540030-886714468.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" /></p><ol start="2"><li><p><a href="https://www.matrixcalculus.org/">一个可以计算梯度的在线工具</a>虽然现在我自己还没玩明白hhh，但是功能应该是很强大</p></li><li><p><a href="https://blog.csdn.net/m0_63238256/article/details/126632188">一个具体推导的例子</a></p></li></ol><hr /><ol start="4"><li><p>更新一个更简单的方式：根据矩阵乘法反向推导更加简单</p><p>比如 正向D = X * W (X:  n * m   W: m * k  D:  n * k)dD 的shape肯定和D一样同理，dW 的shape肯定是m * k,同时dw肯定有dD和X组成，那么根据矩阵乘法原理必须是 x.T.dot(dD)才行</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS231 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷积和池化</title>
      <link href="/2022/10/05/2-ji-suan-ji-shi-jue/cnn/05-juan-ji-chi-hua/"/>
      <url>/2022/10/05/2-ji-suan-ji-shi-jue/cnn/05-juan-ji-chi-hua/</url>
      
        <content type="html"><![CDATA[<p>卷积 输入和输出的关系</p><p>输入 N * N * D    卷积核 K * K * D2 stride(步长)、pad（周围填充）输出尺寸 = ( N + 2 * pad - K ) / stride + 1</p><p><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221024164713580-84738276.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221024164713580-84738276.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><p>反卷积输入输出公式</p><p>pytorch 的反卷积公式：<img src="https://img2023.cnblogs.com/blog/2851436/202212/2851436-20221206225435318-1923273135.png" class="lazyload placeholder" data-srcset="https://img2023.cnblogs.com/blog/2851436/202212/2851436-20221206225435318-1923273135.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><p>注一般取值：</p><p>output_padding  :   stride - 1padding         :   (kernel_size - 1) / 2</p><p>查看源码可以发现：</p><ul><li>Input: :math:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><msub><mi>C</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo separator="true">,</mo><msub><mi>L</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(N, C_{in}, L_{in})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>Output: :math:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><msub><mi>C</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo separator="true">,</mo><msub><mi>L</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(N, C_{out}, L_{out})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> where</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>L</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>L</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mtext>stride</mtext><mo>−</mo><mn>2</mn><mo>×</mo><mtext>padding</mtext><mo>+</mo><mtext>dilation</mtext><mo>×</mo><mo stretchy="false">(</mo><mtext>kernel_size</mtext><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mtext>output_padding</mtext><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">    L_{out} = (L_{in} - 1) \times \text{stride} - 2 \times \text{padding} + \text{dilation}            \times (\text{kernel\_size} - 1) + \text{output\_padding} + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord text"><span class="mord">stride</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">padding</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord text"><span class="mord">dilation</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">kernel_size</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">output_padding</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p>通常dilation = 1 简化为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>L</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">(</mo><msub><mi>L</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo>−</mo><mn>1</mn><mo fence="true">)</mo></mrow><mo>×</mo><mtext>stride</mtext><mo>−</mo><mn>2</mn><mo>×</mo><mtext>padding</mtext><mo>+</mo><mtext>kernel_size</mtext><mo>+</mo><mtext>output_padding</mtext></mrow><annotation encoding="application/x-tex">L_{out}=\left( L_{in}-1 \right) \times \text{stride}-2\times \text{padding}+\text{kernel\_size}+\text{output\_padding}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord text"><span class="mord">stride</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">padding</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">kernel_size</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">output_padding</span></span></span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS231 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反向传播</title>
      <link href="/2022/10/05/2-ji-suan-ji-shi-jue/cnn/04-fan-xiang-chuan-bo/"/>
      <url>/2022/10/05/2-ji-suan-ji-shi-jue/cnn/04-fan-xiang-chuan-bo/</url>
      
        <content type="html"><![CDATA[<p>等后续补充</p>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>损失函数和优化</title>
      <link href="/2022/10/04/2-ji-suan-ji-shi-jue/cnn/03-sun-shi-han-shu-he-you-hua/"/>
      <url>/2022/10/04/2-ji-suan-ji-shi-jue/cnn/03-sun-shi-han-shu-he-you-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="损失函数作用"><a class="markdownIt-Anchor" href="#损失函数作用"></a> 损失函数作用</h3><p>损失函数是一个衡量预测值和真实值之间差异的函数<img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015220021130-696525952.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015220021130-696525952.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><p>Li表示第 i 张图片，预测值的十个输出与真实值之间的差异</p><h4 id="1-hinge-损失函数应用于svm"><a class="markdownIt-Anchor" href="#1-hinge-损失函数应用于svm"></a> 1. hinge 损失函数(应用于SVM)</h4><ol><li>基本思想</li></ol><ul><li>理想的输出的结果 对应的真实标签的得分应该是很高的， 比其他所有类别都高出一定的阈值，这样才好，此时损失值为0</li><li>否则的话就要受到惩罚</li></ul><p><img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015221024642-823893558.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015221024642-823893558.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><ol start="2"><li><p>符号说明：Li表示第i张图片预测值(10个)与真实值产生的误差S 表示 输出的预测的得分，S_y_i表示输出的真实值对应的得分，S_j表示其他类别的得分</p></li><li><p>特性</p></li></ol><ul><li>最小为0（得分最高，且超出一定阈值），最大为无穷（得分为负无穷）</li><li>对结果的轻微扰动不敏感，如car类4.9时已经损失值为0，轻微改变仍是0</li><li>训练最开始时损失函数为 c-1 （c表示种类数，此例c=10）{训练最开始W一般为0-1之前很小的均匀分布的值，第一次输出得到的打分也大概相等，这样c-1 次max(0,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>j</mi></msub><mo>−</mo><msub><mi>s</mi><mrow><mi>y</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_j - s_{yi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>+1) = c-1}</li><li>使得loss==0的W不唯一，但根据奥斯卡姆剃刀原理，我们选取最简单的W，为此可以加上一些惩罚项（正则项）。损失函数变为<img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015223631767-95832827.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015223631767-95832827.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></li><li>如何衡量W简单与否呢?可以使用L1范数、L2范数等等</li></ul><ol><li>向量化实现<img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015223331177-380895889.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015223331177-380895889.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></li></ol><h4 id="2-交叉熵损失函数应用于softmax-loss"><a class="markdownIt-Anchor" href="#2-交叉熵损失函数应用于softmax-loss"></a> 2. 交叉熵损失函数（应用于Softmax loss）</h4><ol><li><p>基本思想真实出现的一定是概率最大的，所以真实值对应的标签概率化后概率应该尽可能大<img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015224350184-1972939571.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015224350184-1972939571.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p></li><li><p>计算过程<img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015224453793-99163284.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015224453793-99163284.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p></li><li><p>特性</p></li></ol><ul><li>最小是0，最大是无穷</li><li>对打分的 小的扰动敏感</li><li>初始损失函数 -log(1/c)=log(c),c表示种类</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> 损失函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单分类器</title>
      <link href="/2022/10/03/2-ji-suan-ji-shi-jue/cnn/02-jian-dan-fen-lei-qi/"/>
      <url>/2022/10/03/2-ji-suan-ji-shi-jue/cnn/02-jian-dan-fen-lei-qi/</url>
      
        <content type="html"><![CDATA[<h3 id="最近邻算法"><a class="markdownIt-Anchor" href="#最近邻算法"></a> 最近邻算法</h3><ol><li>思想：</li></ol><ul><li>训练：只是记录下每个样本的位置和标签</li><li>预测：遍历每个点，看一下距离该点最近的样本点的标签是啥，那他就是哪一类</li><li></li></ul><h3 id="k近邻算法"><a class="markdownIt-Anchor" href="#k近邻算法"></a> K近邻算法</h3><ol><li>思想：</li></ol><ul><li>训练：只是记录下每个样本的位置和标签</li><li>预测：遍历每个点，看一下距离该点最近的K个样本点的标签较多的是啥，那他就是哪一类，如果各类数量一样无法区分</li></ul><ol start="2"><li>实现</li></ol><ul><li>可以多使用模块化思想，数据输入、预处理和分类器模型分开来写，这样方便分类器的复用</li><li>向量化运算可以大大缩短循环所需的时间</li><li>np.sum(a,axis=0) 假设a原本是2 × 3 × 4，对第一维求和后变为 3 × 4</li><li>np.sort(), np.argmin(a)找到a数组中最小的数的索引</li><li>numpy.array_split:将numpy数组分为n份，对于不整除的前面是 1 // n + 1 ..后面是1 // n</li><li>np.concatenate((a,b,c),axis = 0) 将numpy数组a,b,c拼接</li></ul><p>训练完计算准确率常用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num_correct = np.<span class="built_in">sum</span>(y_test_pred == y_test)</span><br><span class="line">accuracy = <span class="built_in">float</span>(num_correct) / num_test</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Got %d / %d correct =&gt; accuracy: %f&#x27;</span> % (num_correct, num_test, accuracy))</span><br></pre></td></tr></table></figure><h3 id="线性分类器"><a class="markdownIt-Anchor" href="#线性分类器"></a> 线性分类器</h3><p>类似于模板匹配CIFAR10 图片分类任务，是个很经典的数据集，图片大小是 <code>32*32*3</code> , 类别是十类<img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015214914968-516055086.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015214914968-516055086.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" /></p><p>输入 1*3072的数据  输出十个数（表示十各类的得分）F(x,W) = Wx + b,就是要找一些数能够使得图片x所对应的标签得分更高<img src="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015215106537-457567375.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2851436/202210/2851436-20221015215106537-457567375.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" />将W可视化后也可以看到大概W就是每类图片的一个公共的特征</p><p>现在只是有了一个打分，但是如何衡量这个打分的好坏，需要量化，我们把这个评价其打分好坏的量化函数叫做<strong>损失函数</strong></p><h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3><ol><li><p>关于划分训练集和测试集</p><ol><li>比较好的思路是划分训练集+验证集+测试集，然后用训练集训练，通过验证集调节超参，调到最好的超参后在测试集上测试准确率，这样的话在模型调节完之前一直接触不到测试集，测试集才能更加好的拟合数据集之外的真实数据</li><li>还有一个思路<em><strong>K折交叉验证</strong></em>，意思是划分为训练集 + 测试集，但是训练集划分为K份，用其中的K-1份进行训练，1份用作验证集调参。（一般用于数据较少的时候，少于一万条？)</li></ol></li><li><p>关于调节超参最好有一个随着超参的每一个值变化，模型准确率变化的图，这样能够更好的描述该参数最好的取值是多少</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS231 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNN 概述</title>
      <link href="/2022/10/02/2-ji-suan-ji-shi-jue/cnn/01-gai-shu/"/>
      <url>/2022/10/02/2-ji-suan-ji-shi-jue/cnn/01-gai-shu/</url>
      
        <content type="html"><![CDATA[<p>斯坦福CS231 视频</p><p><a href="https://www.bilibili.com/video/BV1nJ411z7fe/?spm_id_from=333.999.0.0&amp;vd_source=a25e4be5f25feef1532666f6ee51cce1">视频</a><br /><a href="https://cs231n.github.io/">作业笔记</a></p><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><h3 id="导论"><a class="markdownIt-Anchor" href="#导论"></a> 导论</h3><ol><li>计算机视觉很火 随着传感器(摄像头的的增多）网上80%都是视频</li><li>视频理解很难：可以类比物理学中的暗物质，占据宇宙（网络）中绝大部分，但是很难理解</li><li>比较直观的应用就是短视频平台中需要对用户上传的视频进行分类（好、坏 or 进一步分为搞笑、科普、测评、商务等等）</li><li>2012年 ImageNet 大规模图像分类挑战赛上，CNN第一次崭露头角，将错误率从 26% 降到 16%，人脸检测从2001年的Adabost就开始了，效果还不错</li><li>最厉害的境界是对场景的理解</li></ol><h3 id="研究的问题"><a class="markdownIt-Anchor" href="#研究的问题"></a> 研究的问题</h3><ol><li>图像分类</li><li>目标检测</li><li>图像分割</li><li>图像摘要</li><li>医疗诊断</li><li>自动驾驶</li></ol><h3 id="python和numpy基础教程"><a class="markdownIt-Anchor" href="#python和numpy基础教程"></a> <a href="https://cs231n.github.io/python-numpy-tutorial/">Python和Numpy基础教程</a></h3><p><em><strong>Python</strong></em></p><ol><li>列表表达式 <code>even_squares = [x ** 2 for x in nums if x % 2 == 0]</code></li><li>输入输出 <code>a=int(input(&quot;请输入一个整数&quot;))</code>  <code>print(bin(7),bin(15),'以上两位按位与之后',7&amp;15)</code></li><li>循环<code>for i in range(2,a//2+1):</code><code>for idx, animal in enumerate(animals):</code> //带索引的循环</li></ol><hr /><p><em><strong>Numpy</strong></em></p><ol><li>Matrix *   <code>a.dot(b)</code> or <code>np.dot(a,b)</code></li><li>点乘（对应位置相乘）  a * b</li><li>求矩阵每一列的和  <code>np.sum(x, axis=0)</code></li><li>矩阵转置 <code>V.T</code></li><li><a href="https://numpy.org/doc/stable/user/basics.broadcasting.html">关于广播</a>:会从后往前扫描每一个维度，要么相同，要么有一方维度是1，可以广播此维度</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS231 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy 技巧</title>
      <link href="/2022/10/01/2-ji-suan-ji-shi-jue/cnn/00numpy-ji-qiao/"/>
      <url>/2022/10/01/2-ji-suan-ji-shi-jue/cnn/00numpy-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h3 id="构造列表筛选功能"><a class="markdownIt-Anchor" href="#构造列表筛选功能"></a> 构造列表筛选功能</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array(<span class="built_in">range</span>(<span class="number">6</span>)).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">mask = np.array([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组\n&#x27;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;筛选数组&#x27;</span>,mask)</span><br></pre></td></tr></table></figure><p>原数组[[0 1 2][3 4 5]]筛选数组 [1 2]</p><h4 id="要求实现"><a class="markdownIt-Anchor" href="#要求实现"></a> 要求实现</h4><p>筛选出原数组，第i行的第mask[i]个元素</p><ol><li>循环实现</li><li>向量实现</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 循环实现</span></span><br><span class="line">b=[]</span><br><span class="line"><span class="keyword">for</span> idx,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(mask):</span><br><span class="line">    b.append(a[idx,x])</span><br><span class="line">np.array(b)</span><br></pre></td></tr></table></figure><pre><code>array([1, 5])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 向量实现</span></span><br><span class="line">a[<span class="built_in">range</span>(<span class="built_in">len</span>(mask)),mask]</span><br></pre></td></tr></table></figure><pre><code>array([1, 5])</code></pre><h3 id="numpy-一百题"><a class="markdownIt-Anchor" href="#numpy-一百题"></a> <a href="https://github.com/rougier/numpy-100">Numpy 一百题</a></h3><p>以下为笔记</p><ol><li>数组逆序 <code>Z[::-1]</code> ：取自缩写 of Z[1:10:2]</li><li>查找非0元素的下标  np.nonzero([1,2,3,0,3,0])</li><li>创建 3 * 3 的单位矩阵 np.eye(3)</li><li>创建 3 * 3 * 3 的随机数矩阵 np.random.random((3,3,3))</li><li>数组周围增加一个边界 np.pad(Z, pad_width=1, mode='constant', constant_values=0)</li><li>print(0.3 == 3 * 0.1) # Falseprint(0 * np.nan) # np.nanprint(np.inf &gt; np.nan) #False</li><li>numpy.diag(v, k=0): v 是 2d 则提取对角线元素，v是1d则构建对角矩阵 ， k=1 表示主对角线上边一行，k=-1表示对角线下面一行</li><li>输出棋盘样式的矩阵<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Z = np.ones((<span class="number">8</span>,<span class="number">8</span>),dtype=<span class="string">&#x27;int&#x27;</span>)</span><br><span class="line">Z[:-<span class="number">1</span>:<span class="number">2</span>,<span class="number">0</span>:-<span class="number">1</span>:<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">Z[<span class="number">1</span>::<span class="number">2</span>,<span class="number">1</span>::<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line">answer(<span class="number">19</span>)</span><br><span class="line">--------------------------</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]]</span><br></pre></td></tr></table></figure></li><li>矩阵乘法（真矩阵相乘） <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(X.dot(Y))</span><br><span class="line"><span class="built_in">print</span>(X @ Y)</span><br></pre></td></tr></table></figure></li><li>有一种简写  <code>np.array(range(10))  ---&gt;  np.arange(10)</code></li><li>numpy数组中筛选出 3 到 8 的数值  <code>X[ (X&gt;=3) &amp; (X&lt;=8)]</code></li><li>有趣的题<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">5</span>),-<span class="number">1</span>)) <span class="comment"># 输出 9   这里-1 的意思是前面的和加上一个start值，此处start=-1</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">5</span>),-<span class="number">1</span>)) <span class="comment"># 输出 10  这里-1 的意思是默认对最低维度求和</span></span><br></pre></td></tr></table></figure></li><li>四舍五入<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Y = np.ceil(X)</span><br><span class="line">Z = np.floor(X)</span><br><span class="line">T = np.<span class="built_in">round</span>(X)</span><br></pre></td></tr></table></figure></li><li>找两个数组的交集 <code>np.intersect1d(Z1,Z2)</code></li><li>获得日期的函数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yesterday = np.datetime64(<span class="string">&#x27;today&#x27;</span>) - np.timedelta64(<span class="number">1</span>)</span><br><span class="line">today     = np.datetime64(<span class="string">&#x27;today&#x27;</span>)</span><br><span class="line">tomorrow  = np.datetime64(<span class="string">&#x27;today&#x27;</span>) + np.timedelta64(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li>创建一个5*5的矩阵，每一行都是0-4<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X = np.zeros((<span class="number">5</span>,<span class="number">5</span>),dtype=<span class="built_in">int</span>)</span><br><span class="line">Y = X + np.arange(<span class="number">5</span>)</span><br><span class="line">&lt;!-- ----------- --&gt;</span><br><span class="line">X = np.arange(<span class="number">5</span>)</span><br><span class="line">Y = np.tile(X,(<span class="number">5</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure></li><li>创建10个数线性分布在0-1之间，不包括0、1 <code>Z = np.linspace(0,1,11,endpoint=False)[1:]</code></li><li>随机从1-n个数中选m个<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n , m = <span class="number">25</span>,<span class="number">5</span></span><br><span class="line">np.random.choice(np.arange(<span class="number">1</span>,n+<span class="number">1</span>),m)<span class="comment">#从1 ~ n+1随机选m个</span></span><br><span class="line">np.random.choice(n,m) <span class="comment">#从0~n随机选m个</span></span><br></pre></td></tr></table></figure></li><li>随机从给定区间内抽数，保证等概率 np.random.uniform(a,b,c) 在区间[a,b)内等概率抽取c个，特殊情况下a=0,b=1时等价于random.random(c),想要整数可以使用np.random.randint</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS231 </tag>
            
            <tag> CNN </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机保研经验分享</title>
      <link href="/2022/09/29/4-ri-chang-sui-bi/ji-suan-ji-bao-yan-jing-yan-fen-xiang/"/>
      <url>/2022/09/29/4-ri-chang-sui-bi/ji-suan-ji-bao-yan-jing-yan-fen-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="1-关于保研"><a class="markdownIt-Anchor" href="#1-关于保研"></a> 1. 关于保研</h2><p>随着928的结束，2023届轰轰烈烈的保研也就这么结束了。从五六月份开始准备各种材料，包括打印、签名、写推荐信、成绩证明、证书等等，然后是报无数个学校，填无数个报名系统，最后入营的寥寥无几。夏令营结束也并没有拿到几个offer，预推免经历了套磁十几个老师没一个回复的情况，整个人都很焦虑，好在结束了，谨以此文记录下在带给我莫大痛苦和成长的保研经历。</p><h2 id="2-个人情况"><a class="markdownIt-Anchor" href="#2-个人情况"></a> 2. 个人情况：</h2><p>学校：末流 211</p><p>专业：计算机科学与技术（实验）</p><p>成绩排名：   4/119</p><p>一些成果：国家奖学金 、网络技术挑战赛国家三等奖、有科研经历但无产出（实用新型专利+软著 比较水），还有些水赛</p><h2 id="3-夏令营"><a class="markdownIt-Anchor" href="#3-夏令营"></a> 3. 夏令营</h2><h5 id="没入营"><a class="markdownIt-Anchor" href="#没入营"></a> 没入营</h5><p>南大（cs、se、ai)、上交网安、人大信息、北理cs、华中科技大学cs、华东师范cs、北邮cs15组、哈工大、天大、西交、中南、北交cs</p><h5 id="吉林大学"><a class="markdownIt-Anchor" href="#吉林大学"></a> 吉林大学</h5><p>第一次面试，整个过程比较慌乱，双机位没摆好，周围有噪音等等，抽到的题目是http和https有啥区别，然后项目最开始准备的也不是很好，好在优营发的比较多，拿到了offer</p><h5 id="山大"><a class="markdownIt-Anchor" href="#山大"></a> 山大</h5><p>山大有机试，还挺难的，5道题做出来半道hhh（这里建议多刷算法题，保研找工作都用得到）。面试问了快排、图论（大概是看到了我一个算法竞赛的奖）项目问的很少，有的面试组只问项目很奇怪哈哈哈，最后是候补，结束后又参加了ilearn实验室的面试，学长面试很硬核哈，包括英语口语（介绍下你拿到的奖项）、数学（线代 --秩、概率论）、数据结构（算法实现全排列），最后拿到了学硕offer   {最后又说名 额少变卦啦，这是后话}</p><h5 id="信工所国重"><a class="markdownIt-Anchor" href="#信工所国重"></a> 信工所国重</h5><p>信工所国家重点实验室，报的一个比较火的老师，面试的时候问的数据结构链表之类的，还有项目里的短时傅里叶变化和傅里叶变换的关系等等，没想到问这个项目hhh，老师最后问我接不接受调剂，感觉答得不好，就说接受调剂（其实调剂了别的组大概率就不去了hhh），最后准备不足，拿到了候补（9.27候补到了专硕）</p><h5 id="南开大学"><a class="markdownIt-Anchor" href="#南开大学"></a> 南开大学</h5><p>南开计算机和网安都是自己联系导师，我联系了一个网络安全方向和自己做的项目比较接近的老师，老师问了好多团队合作方便的问题，比如如果你是队长队员跟不上进度怎么办，你是队员，完不成队长的任务怎么办，还问了磁盘去除重复文件的问题，感觉回答的还行，最后拿到了专硕offer。不过南开专硕今年没宿舍，纠结了很久。</p><h5 id="计算所"><a class="markdownIt-Anchor" href="#计算所"></a> 计算所</h5><p>计算所没有入营，不过之前联系的老师，然后霸面（就是没入营的获得了老师推荐也可以直接参加考核），比较奇怪的是之前这老师没给我回邮件，但是直接让我霸面了，可能是联系这个老师的比较少吧hhh，考核就是机试+面试，机试就是一些数据结构的题，正常水平，五道做了三道，面试感觉答的还行，问的不是很深，不过计算所是最后把你的机试和面试成绩告诉老师，老师决定要不要你，我面试完也没有再联系那个老师（感觉那老师研究方向比较偏hhh），然后最后没拿到offer。</p><h5 id="东南大学"><a class="markdownIt-Anchor" href="#东南大学"></a> 东南大学</h5><p>今年东南大学是要求先联系导师，获得导师的推荐名额之后才能有机会入营，我联系了计院一个做网安的老师lz，面了50min，把我做的四个项目从头到尾问了个遍，还问了计网相关的问题：“从输入网址到显示出网页来，后台发生了什么，用到了什么网络协议？”，感觉整体还行，当时老师就给了计科的名额（老师的推荐名额也是有限的，然后计科名额比较少，软件的多），入营后学院面试的时候问的项目里用到的LSTM以及数据结构算法中的内部排序、外部排序，感觉回答的不是很好，而且面试过程听到的老师的话都是断断续续的，需要听到关键词，然后猜测老师的问题是啥，体验很差，最后没拿到offer。</p><p>offer：吉林大学cs、山大cs候补（ilearn offer）、信工所国重候补、南开网安</p><h2 id="4-预推免"><a class="markdownIt-Anchor" href="#4-预推免"></a> 4. 预推免</h2><p>没入营：北航网安、北理cs、国防科大cs、厦门大学cs、软件所、同济</p><p>因为拿了夏令营南开和山大offer，就没有报太多，报的都挺高的hhh</p><h5 id="北邮cs"><a class="markdownIt-Anchor" href="#北邮cs"></a> 北邮cs</h5><p>预推免的时候北邮好多老师都招满了，北邮是弱com，就是那种老师想要基本就能要的，不需要统一考核，老师夏令营基本招满了，然后预推免的时候鸽子还没起飞，发了好多套磁老师的邮件，北邮是分组考核的，15组考核全程问项目，问了大概40min，刚面完15组还没出结果的时候16组一个老师又开始面，面完说感觉不错，但还得完成个小任务考核类似于 先爬虫搜集公交车数据，然后实现一个路径规划的系统。刚面完就接到15组的offer，老师说预计是学硕，然后给16组老师说明情况，老师说也可以给我学硕、也不用做考核了（打起来啦哈哈哈），最后综合选择后拒掉了16组老师，选择15组学硕（15组是北邮比较火的一组）。（拿到北邮cs  offer后拒掉了南开老师，但后来北邮15组老师又开始问我接不接受专硕，说只能给专硕，被搞了一手很难受）</p><h5 id="天津大学"><a class="markdownIt-Anchor" href="#天津大学"></a> 天津大学</h5><p>入营后放弃</p><h5 id="计算所无线中心"><a class="markdownIt-Anchor" href="#计算所无线中心"></a> 计算所无线中心</h5><p>报名后老师打电话通知面试，主要就是讲项目，不过老师问了编译链接的过程、七层网络模型及其作用、神经网络中卷积的过程、离散傅里叶和连续傅里叶的区别等等，感觉面得还可以，不过可能只要两个名额竞争太大，老师打电话说只能给一个计算所和上科大联培的名额，考虑后拒绝了。（9.26收到了通知说可以给计算所的offer，不过第一年在南京培养）</p><h5 id="浙大工程师院"><a class="markdownIt-Anchor" href="#浙大工程师院"></a> 浙大工程师院</h5><p>浙工我没报太大希望，就没怎么准备，主要问了下SDN的项目，还是一些加密算法（项目涉及到的），然后英文介绍家乡，等等，感觉答得不是很好，最后是候补第六位。（总共要8个人，也就是说我前面13个人放弃6个我才有希望，当时感觉希望不大）</p><h5 id="华中科技大学"><a class="markdownIt-Anchor" href="#华中科技大学"></a> 华中科技大学</h5><p>华科首先是机试，三道题（字符串处理*2+双栈求解逻辑表达式），挺水的，做出来两道半，然后是面试也很水hhh，应该主要是看机试+背景吧，最后拿到了候补，联系老师面试主要问了编程能力和项目，老师说基本是稳的，不过可能是专硕。老师做核心算法优化之类的，专硕没宿舍实验室会有各种补助，花销和校内差不多，会给安排大厂实习，当时问的很详细，感觉很可能就去了哈哈哈。</p><p>offer：北邮cs 15组、计算所无线中心 候补、华科cs候补、浙大工程师院候补</p><h2 id="5-推免系统开放"><a class="markdownIt-Anchor" href="#5-推免系统开放"></a> 5. 推免系统开放</h2><p>最后感觉手里比较好的排就是 华科候补 北邮cs  浙工候补 计算所无线中心，因为只能填三个志愿，最后拒绝了计算所offer，选择北邮保底，冲华科和浙工，最后上岸浙工。</p><p>最后好多都被割穿了</p><p>西交软、中山、浙软、北邮、吉大、东南网安、人大gl、北航计算所、武汉大学计算机、南大计算机等等</p><p>以上学校基本都是候补都能录，然后录完还有剩余名额招不到学生。所以最后三个志愿可以搏一搏哈哈哈，搏一搏单车变摩托！（但也有可能只能留本校了哈哈哈，风险与机遇并存）</p><h2 id="最后附计算机类院校排行榜"><a class="markdownIt-Anchor" href="#最后附计算机类院校排行榜"></a> 最后附计算机类院校排行榜</h2><p><a href="https://www.cnblogs.com/da-zhi/p/16757151.html">附计算机类院校排行榜汇总</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 入门</title>
      <link href="/2022/09/01/1-kai-fa/git/git-ru-men/"/>
      <url>/2022/09/01/1-kai-fa/git/git-ru-men/</url>
      
        <content type="html"><![CDATA[<h4 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h4><p><code>git status</code> 当前仓库的状态</p><p><code>git add &quot;filename.txt&quot;</code>向暂存区添加文件</p><p><code>git commit -m &quot;描述语句&quot;</code>提交暂存区文件</p><p><code>git diff</code>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p><p><code>git log</code>显示该仓库所有提交记录，简洁版是<code>git log --pretty=oneline</code></p><h4 id="时空穿梭"><a class="markdownIt-Anchor" href="#时空穿梭"></a> 时空穿梭</h4><ul><li>回到过去</li></ul><ol><li><code>git reset --hard HEAD^</code>回退到上一个版本</li><li><code>git log</code> 查看过去提交的版本号id，然后用<code>git reset --hard id</code>即可</li></ol><ul><li>重返未来</li></ul><ol><li><code>git reflog</code> 查看命令历史，看到未来的版本号id，然后使用<code>git reset --hard id</code>重返未来</li></ol><h4 id="git管理的文件分为"><a class="markdownIt-Anchor" href="#git管理的文件分为"></a> Git管理的文件分为</h4><ul><li><p>工作区</p></li><li><p>版本库，</p><ul><li>暂存区stage</li><li>暂存区分支master(仓库)</li></ul></li></ul><p><code>git add</code>把文件从工作区&gt;&gt;&gt;&gt;暂存区，<code>git commit</code>把文件从暂存区&gt;&gt;&gt;&gt;仓库，</p><p><strong>git diff 三件套</strong></p><p><code>git diff</code>查看工作区和暂存区差异</p><p><code>git diff --cached</code>查看暂存区和仓库差异，</p><p><code>git diff HEAD</code> 查看工作区和仓库的差异，</p><p><strong>注</strong> : 暂存区为空使用git diff：因为此时暂存区为空，此时使</p><p>用git diff同样也是比较工作区和仓库，即和使用git diff HEAD结果相同</p><p><strong>文件传输</strong></p><p><code>git add</code>的反向命令<code>git checkout</code> -- file，撤销工作区修改，即把暂存区（若空则为仓库）最新版本转移到工作区，</p><p><code>git commit</code>的反向命令<code>git reset HEAD &lt;file&gt;</code>，就是把仓库最新版本转移到暂存区。</p><p>删除文件 <code>git rm file</code>然后<code>git commit -m &quot;remove file&quot;</code></p><p>最最常用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">新建文件，或者修改后</span><br><span class="line">git add . //将所有的修改提交到暂存区</span><br><span class="line">git commit -m &quot;版本提交注释&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ssh-keygen -R 20.205.243.166</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
